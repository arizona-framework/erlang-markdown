%%% % DO NOT EDIT: this file was generated by 'just codegen'
%%% % @generated SignedSource<<8a45d60290660ba4fc549183481e38bd>>
%%%-----------------------------------------------------------------------------
%%% %CopyrightBegin%
%%%
%%% SPDX-License-Identifier: Apache-2.0
%%%
%%% Copyright (c) Meta Platforms, Inc. and affiliates.
%%% Copyright (c) WhatsApp LLC
%%%
%%% Licensed under the Apache License, Version 2.0 (the "License");
%%% you may not use this file except in compliance with the License.
%%% You may obtain a copy of the License at
%%%
%%%     http://www.apache.org/licenses/LICENSE-2.0
%%%
%%% Unless required by applicable law or agreed to in writing, software
%%% distributed under the License is distributed on an "AS IS" BASIS,
%%% WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
%%% See the License for the specific language governing permissions and
%%% limitations under the License.
%%%
%%% %CopyrightEnd%
%%%-----------------------------------------------------------------------------
%%% % @format
-module(markdown_html_flow_SUITE).
-moduledoc """

""".
-moduledoc #{author => ["Andrew Bennett <potatosaladx@meta.com>"]}.
-moduledoc #{created => "", modified => ""}.
-moduledoc #{copyright => "Meta Platforms, Inc. and affiliates."}.
-compile(warn_missing_spec_all).
-oncall("whatsapp_clr").

-include_lib("markdown/include/markdown_mdast.hrl").
-include_lib("markdown/include/markdown_util.hrl").
-include_lib("stdlib/include/assert.hrl").

-behaviour(ct_suite).

%% ct_suite callbacks
-export([
    all/0,
    groups/0,
    init_per_suite/1,
    end_per_suite/1,
    init_per_group/2,
    end_per_group/2
]).

%% Test Cases
-export([
    test_html_flow_case_1/1,
    test_html_flow_case_2/1,
    test_html_flow_case_3/1,
    test_html_flow_case_4/1,
    test_html_flow_case_5/1,
    test_html_flow_case_6/1,
    test_html_flow_case_7/1,
    test_html_flow_case_8/1,
    test_html_flow_case_9/1,
    test_html_flow_case_10/1,
    test_html_flow_case_11/1,
    test_html_flow_case_12/1,
    test_html_flow_case_13/1,
    test_html_flow_case_14/1,
    test_html_flow_case_15/1,
    test_html_flow_case_16/1,
    test_html_flow_case_17/1,
    test_html_flow_case_18/1,
    test_html_flow_case_19/1,
    test_html_flow_case_20/1,
    test_html_flow_case_21/1,
    test_html_flow_case_22/1,
    test_html_flow_case_23/1,
    test_html_flow_case_24/1,
    test_html_flow_case_25/1,
    test_html_flow_case_26/1,
    test_html_flow_case_27/1,
    test_html_flow_case_28/1,
    test_html_flow_case_29/1,
    test_html_flow_case_30/1,
    test_html_flow_case_31/1,
    test_html_flow_case_32/1,
    test_html_flow_case_33/1,
    test_html_flow_case_34/1,
    test_html_flow_case_35/1,
    test_html_flow_case_36/1,
    test_html_flow_case_37/1,
    test_html_flow_case_38/1,
    test_html_flow_case_39/1,
    test_html_flow_case_40/1,
    test_html_flow_case_41/1,
    test_html_flow_case_42/1,
    test_html_flow_case_43/1,
    test_html_flow_case_44/1,
    test_html_flow_case_45/1,
    test_html_flow_case_46/1,
    test_html_flow_case_47/1,
    test_html_flow_case_48/1,
    test_html_flow_case_49/1,
    test_html_flow_case_50/1,
    test_html_flow_case_51/1,
    test_html_flow_case_52/1,
    test_html_flow_case_53/1,
    test_html_flow_case_54/1,
    test_html_flow_case_55/1,
    test_html_flow_case_56/1,
    test_html_flow_case_57/1,
    test_html_flow_case_58/1,
    test_html_flow_case_59/1,
    test_html_flow_case_60/1,
    test_html_flow_case_61/1,
    test_html_flow_case_62/1,
    test_html_flow_case_63/1,
    test_html_flow_case_64/1,
    test_html_flow_case_65/1,
    test_html_flow_case_66/1,
    test_html_flow_case_67/1,
    test_html_flow_case_68/1,
    test_html_flow_case_69/1,
    test_html_flow_case_70/1,
    test_html_flow_case_71/1,
    test_html_flow_case_72/1,
    test_html_flow_case_73/1,
    test_html_flow_case_74/1,
    test_html_flow_case_75/1,
    test_html_flow_case_76/1,
    test_html_flow_case_77/1,
    test_html_flow_case_78/1,
    test_html_flow_case_79/1,
    test_html_flow_case_80/1,
    test_html_flow_case_81/1,
    test_html_flow_case_82/1,
    test_html_flow_case_83/1,
    test_html_flow_case_84/1,
    test_html_flow_case_85/1,
    test_html_flow_case_86/1,
    test_html_flow_case_87/1,
    test_html_flow_case_88/1,
    test_html_flow_case_89/1,
    test_html_flow_case_90/1,
    test_html_flow_case_91/1,
    test_html_flow_case_92/1,
    test_html_flow_case_93/1,
    test_html_flow_case_94/1,
    test_html_flow_case_95/1,
    test_html_flow_case_96/1,
    test_html_flow_case_97/1,
    test_html_flow_case_98/1,
    test_html_flow_case_99/1,
    test_html_flow_case_100/1,
    test_html_flow_case_101/1,
    test_html_flow_case_102/1,
    test_html_flow_case_103/1,
    test_html_flow_case_104/1,
    test_html_flow_case_105/1,
    test_html_flow_case_106/1,
    test_html_flow_case_107/1,
    test_html_flow_case_108/1,
    test_html_flow_case_109/1,
    test_html_flow_case_110/1,
    test_html_flow_case_111/1,
    test_html_flow_case_112/1,
    test_html_flow_case_113/1,
    test_html_flow_case_114/1,
    test_html_flow_case_115/1,
    test_html_flow_case_116/1,
    test_html_flow_case_117/1,
    test_html_flow_case_118/1,
    test_html_flow_case_119/1,
    test_html_flow_case_120/1,
    test_html_flow_case_121/1,
    test_html_flow_case_122/1,
    test_html_flow_case_123/1,
    test_html_flow_case_124/1,
    test_html_flow_case_125/1,
    test_html_flow_case_126/1,
    test_html_flow_case_127/1,
    test_html_flow_case_128/1,
    test_html_flow_case_129/1,
    test_html_flow_case_130/1,
    test_html_flow_case_131/1,
    test_html_flow_case_132/1,
    test_html_flow_case_133/1,
    test_html_flow_case_134/1,
    test_html_flow_case_135/1,
    test_html_flow_case_136/1,
    test_html_flow_case_137/1,
    test_html_flow_case_138/1,
    test_html_flow_case_139/1,
    test_html_flow_case_140/1,
    test_html_flow_case_141/1,
    test_html_flow_case_142/1,
    test_html_flow_case_143/1,
    test_html_flow_case_144/1,
    test_html_flow_case_145/1,
    test_html_flow_case_146/1,
    test_html_flow_case_147/1,
    test_html_flow_case_148/1,
    test_html_flow_case_149/1,
    test_html_flow_case_150/1,
    test_html_flow_case_151/1
]).

%% Macros
-define(danger, markdown_options:new(#{compile => #{allow_dangerous_html => true, allow_dangerous_protocol => true}})).

%%%=============================================================================
%%% ct_suite callbacks
%%%=============================================================================

-spec all() -> markdown_test:all().
all() ->
    [
        {group, static}
    ].

-spec groups() -> markdown_test:groups().
groups() ->
    [
        {static, [parallel], [
            test_html_flow_case_1,
            test_html_flow_case_2,
            test_html_flow_case_3,
            test_html_flow_case_4,
            test_html_flow_case_5,
            test_html_flow_case_6,
            test_html_flow_case_7,
            test_html_flow_case_8,
            test_html_flow_case_9,
            test_html_flow_case_10,
            test_html_flow_case_11,
            test_html_flow_case_12,
            test_html_flow_case_13,
            test_html_flow_case_14,
            test_html_flow_case_15,
            test_html_flow_case_16,
            test_html_flow_case_17,
            test_html_flow_case_18,
            test_html_flow_case_19,
            test_html_flow_case_20,
            test_html_flow_case_21,
            test_html_flow_case_22,
            test_html_flow_case_23,
            test_html_flow_case_24,
            test_html_flow_case_25,
            test_html_flow_case_26,
            test_html_flow_case_27,
            test_html_flow_case_28,
            test_html_flow_case_29,
            test_html_flow_case_30,
            test_html_flow_case_31,
            test_html_flow_case_32,
            test_html_flow_case_33,
            test_html_flow_case_34,
            test_html_flow_case_35,
            test_html_flow_case_36,
            test_html_flow_case_37,
            test_html_flow_case_38,
            test_html_flow_case_39,
            test_html_flow_case_40,
            test_html_flow_case_41,
            test_html_flow_case_42,
            test_html_flow_case_43,
            test_html_flow_case_44,
            test_html_flow_case_45,
            test_html_flow_case_46,
            test_html_flow_case_47,
            test_html_flow_case_48,
            test_html_flow_case_49,
            test_html_flow_case_50,
            test_html_flow_case_51,
            test_html_flow_case_52,
            test_html_flow_case_53,
            test_html_flow_case_54,
            test_html_flow_case_55,
            test_html_flow_case_56,
            test_html_flow_case_57,
            test_html_flow_case_58,
            test_html_flow_case_59,
            test_html_flow_case_60,
            test_html_flow_case_61,
            test_html_flow_case_62,
            test_html_flow_case_63,
            test_html_flow_case_64,
            test_html_flow_case_65,
            test_html_flow_case_66,
            test_html_flow_case_67,
            test_html_flow_case_68,
            test_html_flow_case_69,
            test_html_flow_case_70,
            test_html_flow_case_71,
            test_html_flow_case_72,
            test_html_flow_case_73,
            test_html_flow_case_74,
            test_html_flow_case_75,
            test_html_flow_case_76,
            test_html_flow_case_77,
            test_html_flow_case_78,
            test_html_flow_case_79,
            test_html_flow_case_80,
            test_html_flow_case_81,
            test_html_flow_case_82,
            test_html_flow_case_83,
            test_html_flow_case_84,
            test_html_flow_case_85,
            test_html_flow_case_86,
            test_html_flow_case_87,
            test_html_flow_case_88,
            test_html_flow_case_89,
            test_html_flow_case_90,
            test_html_flow_case_91,
            test_html_flow_case_92,
            test_html_flow_case_93,
            test_html_flow_case_94,
            test_html_flow_case_95,
            test_html_flow_case_96,
            test_html_flow_case_97,
            test_html_flow_case_98,
            test_html_flow_case_99,
            test_html_flow_case_100,
            test_html_flow_case_101,
            test_html_flow_case_102,
            test_html_flow_case_103,
            test_html_flow_case_104,
            test_html_flow_case_105,
            test_html_flow_case_106,
            test_html_flow_case_107,
            test_html_flow_case_108,
            test_html_flow_case_109,
            test_html_flow_case_110,
            test_html_flow_case_111,
            test_html_flow_case_112,
            test_html_flow_case_113,
            test_html_flow_case_114,
            test_html_flow_case_115,
            test_html_flow_case_116,
            test_html_flow_case_117,
            test_html_flow_case_118,
            test_html_flow_case_119,
            test_html_flow_case_120,
            test_html_flow_case_121,
            test_html_flow_case_122,
            test_html_flow_case_123,
            test_html_flow_case_124,
            test_html_flow_case_125,
            test_html_flow_case_126,
            test_html_flow_case_127,
            test_html_flow_case_128,
            test_html_flow_case_129,
            test_html_flow_case_130,
            test_html_flow_case_131,
            test_html_flow_case_132,
            test_html_flow_case_133,
            test_html_flow_case_134,
            test_html_flow_case_135,
            test_html_flow_case_136,
            test_html_flow_case_137,
            test_html_flow_case_138,
            test_html_flow_case_139,
            test_html_flow_case_140,
            test_html_flow_case_141,
            test_html_flow_case_142,
            test_html_flow_case_143,
            test_html_flow_case_144,
            test_html_flow_case_145,
            test_html_flow_case_146,
            test_html_flow_case_147,
            test_html_flow_case_148,
            test_html_flow_case_149,
            test_html_flow_case_150,
            test_html_flow_case_151
        ]}
    ].

-spec init_per_suite(Config :: ct_suite:ct_config()) -> markdown_test:init_per_suite().
init_per_suite(Config) ->
    Config.

-spec end_per_suite(Config :: ct_suite:ct_config()) -> markdown_test:end_per_suite().
end_per_suite(_Config) ->
    ok.

-spec init_per_group(GroupName :: ct_suite:ct_groupname(), Config :: ct_suite:ct_config()) ->
    markdown_test:init_per_group().
init_per_group(_Group, Config) ->
    Config.

-spec end_per_group(GroupName :: ct_suite:ct_groupname(), Config :: ct_suite:ct_config()) ->
    markdown_test:end_per_group().
end_per_group(_Group, _Config) ->
    ok.

%%%=============================================================================
%%% Test Cases
%%%=============================================================================

-spec test_html_flow_case_1(Config) -> markdown_test:testcase() when
    Config :: ct_suite:ct_config().
test_html_flow_case_1(_Config) ->
    ?assertMatch(
        {ok, <<"&lt;!-- asd --&gt;"/utf8>>},
        markdown:to_html(<<"<!-- asd -->"/utf8>>),
        "should support a heading w/ rank 1"
    ),
    ok.

-spec test_html_flow_case_2(Config) -> markdown_test:testcase() when
    Config :: ct_suite:ct_config().
test_html_flow_case_2(_Config) ->
    ?assertMatch(
        {ok, <<"<!-- asd -->"/utf8>>},
        markdown:to_html_with_options(<<"<!-- asd -->"/utf8>>, ?danger),
        "should support a heading w/ rank 1"
    ),
    ok.

-spec test_html_flow_case_3(Config) -> markdown_test:testcase() when
    Config :: ct_suite:ct_config().
test_html_flow_case_3(_Config) ->
    ?assertMatch(
        {ok, <<"<p>&lt;x&gt;</p>"/utf8>>},
        markdown:to_html_with_options(
            <<"<x>"/utf8>>, markdown_options:default(#{parse => #{constructs => #{html_flow => false}}})
        ),
        "should support turning off html (flow)"
    ),
    ok.

-spec test_html_flow_case_4(Config) -> markdown_test:testcase() when
    Config :: ct_suite:ct_config().
test_html_flow_case_4(_Config) ->
    ?assertEqual(
        {ok,
            markdown_mdast_node:root(#markdown_mdast_root{
                children = ?'vec!'([
                    markdown_mdast_node:html(#markdown_mdast_html{
                        value = <<"<div>\nstuff\n</div>">>,
                        position = {some, markdown_unist_position:new(1, 1, 0, 3, 7, 18)}
                    })
                ]),
                position = {some, markdown_unist_position:new(1, 1, 0, 3, 7, 18)}
            })},
        markdown:to_mdast(<<"<div>\nstuff\n</div>"/utf8>>, markdown_parse_options:default()),
        "should support HTML (flow) as `Html`s in mdast"
    ),
    ok.

-spec test_html_flow_case_5(Config) -> markdown_test:testcase() when
    Config :: ct_suite:ct_config().
test_html_flow_case_5(_Config) ->
    ?assertMatch(
        {ok, <<"""
        <pre language="haskell"><code>
        import Text.HTML.TagSoup

        main :: IO ()
        main = print $ parseTags tags
        </code></pre>
        <p>okay</p>
        """/utf8>>},
        markdown:to_html_with_options(
            <<"<pre language=\"haskell\"><code>\nimport Text.HTML.TagSoup\n\nmain :: IO ()\nmain = print $ parseTags tags\n</code></pre>\nokay"/utf8>>,
            ?danger
        ),
        "should support raw pre tags (type 1)"
    ),
    ok.

-spec test_html_flow_case_6(Config) -> markdown_test:testcase() when
    Config :: ct_suite:ct_config().
test_html_flow_case_6(_Config) ->
    ?assertMatch(
        {ok, <<"""
        <script type="text/javascript">
        // JavaScript example

        document.getElementById("demo").innerHTML = "Hello JavaScript!";
        </script>
        <p>okay</p>
        """/utf8>>},
        markdown:to_html_with_options(<<"""
        <script type="text/javascript">
        // JavaScript example

        document.getElementById("demo").innerHTML = "Hello JavaScript!";
        </script>
        okay
        """/utf8>>, ?danger),
        "should support raw script tags"
    ),
    ok.

-spec test_html_flow_case_7(Config) -> markdown_test:testcase() when
    Config :: ct_suite:ct_config().
test_html_flow_case_7(_Config) ->
    ?assertMatch(
        {ok, <<"<style\n  type=\"text/css\">\nh1 {color:red;}\n\np {color:blue;}\n</style>\n<p>okay</p>"/utf8>>},
        markdown:to_html_with_options(
            <<"<style\n  type=\"text/css\">\nh1 {color:red;}\n\np {color:blue;}\n</style>\nokay"/utf8>>, ?danger
        ),
        "should support raw style tags"
    ),
    ok.

-spec test_html_flow_case_8(Config) -> markdown_test:testcase() when
    Config :: ct_suite:ct_config().
test_html_flow_case_8(_Config) ->
    ?assertMatch(
        {ok, <<"<style\n  type=\"text/css\">\n\nfoo"/utf8>>},
        markdown:to_html_with_options(<<"<style\n  type=\"text/css\">\n\nfoo"/utf8>>, ?danger),
        "should support raw tags w/o ending"
    ),
    ok.

-spec test_html_flow_case_9(Config) -> markdown_test:testcase() when
    Config :: ct_suite:ct_config().
test_html_flow_case_9(_Config) ->
    ?assertMatch(
        {ok, <<"<style>p{color:red;}</style>\n<p><em>foo</em></p>"/utf8>>},
        markdown:to_html_with_options(<<"<style>p{color:red;}</style>\n*foo*"/utf8>>, ?danger),
        "should support raw tags w/ start and end on a single line"
    ),
    ok.

-spec test_html_flow_case_10(Config) -> markdown_test:testcase() when
    Config :: ct_suite:ct_config().
test_html_flow_case_10(_Config) ->
    ?assertMatch(
        {ok, <<"<script>\nfoo\n</script>1. *bar*"/utf8>>},
        markdown:to_html_with_options(<<"<script>\nfoo\n</script>1. *bar*"/utf8>>, ?danger),
        "should support raw tags w/ more data on ending line"
    ),
    ok.

-spec test_html_flow_case_11(Config) -> markdown_test:testcase() when
    Config :: ct_suite:ct_config().
test_html_flow_case_11(_Config) ->
    ?assertMatch(
        {ok, <<"<script"/utf8>>},
        markdown:to_html_with_options(<<"<script"/utf8>>, ?danger),
        "should support an eof directly after a raw tag name"
    ),
    ok.

-spec test_html_flow_case_12(Config) -> markdown_test:testcase() when
    Config :: ct_suite:ct_config().
test_html_flow_case_12(_Config) ->
    ?assertMatch(
        {ok, <<"<p>&lt;/script\nmore</p>"/utf8>>},
        markdown:to_html_with_options(<<"</script\nmore"/utf8>>, ?danger),
        "should not support a raw closing tag"
    ),
    ok.

-spec test_html_flow_case_13(Config) -> markdown_test:testcase() when
    Config :: ct_suite:ct_config().
test_html_flow_case_13(_Config) ->
    ?assertMatch(
        {ok, <<"<p>&lt;script/</p>"/utf8>>},
        markdown:to_html_with_options(<<"<script/"/utf8>>, ?danger),
        "should not support an eof after a self-closing slash"
    ),
    ok.

-spec test_html_flow_case_14(Config) -> markdown_test:testcase() when
    Config :: ct_suite:ct_config().
test_html_flow_case_14(_Config) ->
    ?assertMatch(
        {ok, <<"<p>&lt;script/\n<em>asd</em></p>"/utf8>>},
        markdown:to_html_with_options(<<"<script/\n*asd*"/utf8>>, ?danger),
        "should not support a line ending after a self-closing slash"
    ),
    ok.

-spec test_html_flow_case_15(Config) -> markdown_test:testcase() when
    Config :: ct_suite:ct_config().
test_html_flow_case_15(_Config) ->
    ?assertMatch(
        {ok, <<"<script/>"/utf8>>},
        markdown:to_html_with_options(<<"<script/>"/utf8>>, ?danger),
        "should support an eof after a self-closing tag"
    ),
    ok.

-spec test_html_flow_case_16(Config) -> markdown_test:testcase() when
    Config :: ct_suite:ct_config().
test_html_flow_case_16(_Config) ->
    ?assertMatch(
        {ok, <<"<script/>\na"/utf8>>},
        markdown:to_html_with_options(<<"<script/>\na"/utf8>>, ?danger),
        "should support a line ending after a self-closing tag"
    ),
    ok.

-spec test_html_flow_case_17(Config) -> markdown_test:testcase() when
    Config :: ct_suite:ct_config().
test_html_flow_case_17(_Config) ->
    ?assertMatch(
        {ok, <<"<p><script/>a</p>"/utf8>>},
        markdown:to_html_with_options(<<"<script/>a"/utf8>>, ?danger),
        "should not support other characters after a self-closing tag"
    ),
    ok.

-spec test_html_flow_case_18(Config) -> markdown_test:testcase() when
    Config :: ct_suite:ct_config().
test_html_flow_case_18(_Config) ->
    ?assertMatch(
        {ok, <<"<script>a"/utf8>>},
        markdown:to_html_with_options(<<"<script>a"/utf8>>, ?danger),
        "should support other characters after a raw opening tag"
    ),
    ok.

-spec test_html_flow_case_19(Config) -> markdown_test:testcase() when
    Config :: ct_suite:ct_config().
test_html_flow_case_19(_Config) ->
    %% Extra.
    ?assertMatch(
        {ok, <<"<p>Foo</p>\n<script"/utf8>>},
        markdown:to_html_with_options(<<"Foo\n<script"/utf8>>, ?danger),
        "should support interrupting paragraphs w/ raw tags"
    ),
    ok.

-spec test_html_flow_case_20(Config) -> markdown_test:testcase() when
    Config :: ct_suite:ct_config().
test_html_flow_case_20(_Config) ->
    ?assertMatch(
        {ok, <<"<script>a</script\nb"/utf8>>},
        markdown:to_html_with_options(<<"<script>a</script\nb"/utf8>>, ?danger),
        "should not support stopping raw if the closing tag does not have a `>`"
    ),
    ok.

-spec test_html_flow_case_21(Config) -> markdown_test:testcase() when
    Config :: ct_suite:ct_config().
test_html_flow_case_21(_Config) ->
    ?assertMatch(
        {ok, <<"<script>\n  \n  \n</script>"/utf8>>},
        markdown:to_html_with_options(<<"<script>\n  \n  \n</script>"/utf8>>, ?danger),
        "should support blank lines in raw"
    ),
    ok.

-spec test_html_flow_case_22(Config) -> markdown_test:testcase() when
    Config :: ct_suite:ct_config().
test_html_flow_case_22(_Config) ->
    ?assertMatch(
        {ok, <<"<blockquote>\n<script>\n</blockquote>\n<p>a</p>"/utf8>>},
        markdown:to_html_with_options(<<"> <script>\na"/utf8>>, ?danger),
        "should not support lazyness (1)"
    ),
    ok.

-spec test_html_flow_case_23(Config) -> markdown_test:testcase() when
    Config :: ct_suite:ct_config().
test_html_flow_case_23(_Config) ->
    ?assertMatch(
        {ok, <<"<blockquote>\n<p>a</p>\n</blockquote>\n<script>"/utf8>>},
        markdown:to_html_with_options(<<"> a\n<script>"/utf8>>, ?danger),
        "should not support lazyness (2)"
    ),
    ok.

-spec test_html_flow_case_24(Config) -> markdown_test:testcase() when
    Config :: ct_suite:ct_config().
test_html_flow_case_24(_Config) ->
    ?assertMatch(
        {ok, <<"<!-- Foo\n\nbar\n   baz -->\n<p>okay</p>"/utf8>>},
        markdown:to_html_with_options(<<"<!-- Foo\n\nbar\n   baz -->\nokay"/utf8>>, ?danger),
        "should support comments (type 2)"
    ),
    ok.

-spec test_html_flow_case_25(Config) -> markdown_test:testcase() when
    Config :: ct_suite:ct_config().
test_html_flow_case_25(_Config) ->
    ?assertMatch(
        {ok, <<"<!-- foo -->*bar*\n<p><em>baz</em></p>"/utf8>>},
        markdown:to_html_with_options(<<"<!-- foo -->*bar*\n*baz*"/utf8>>, ?danger),
        "should support comments w/ start and end on a single line"
    ),
    ok.

-spec test_html_flow_case_26(Config) -> markdown_test:testcase() when
    Config :: ct_suite:ct_config().
test_html_flow_case_26(_Config) ->
    ?assertMatch(
        {ok, <<"<p>&lt;!-asd--&gt;</p>"/utf8>>},
        markdown:to_html_with_options(<<"<!-asd-->"/utf8>>, ?danger),
        "should not support a single dash to start comments"
    ),
    ok.

-spec test_html_flow_case_27(Config) -> markdown_test:testcase() when
    Config :: ct_suite:ct_config().
test_html_flow_case_27(_Config) ->
    ?assertMatch(
        {ok, <<"<!-->"/utf8>>},
        markdown:to_html_with_options(<<"<!-->"/utf8>>, ?danger),
        "should support comments where the start dashes are the end dashes (1)"
    ),
    ok.

-spec test_html_flow_case_28(Config) -> markdown_test:testcase() when
    Config :: ct_suite:ct_config().
test_html_flow_case_28(_Config) ->
    ?assertMatch(
        {ok, <<"<!--->"/utf8>>},
        markdown:to_html_with_options(<<"<!--->"/utf8>>, ?danger),
        "should support comments where the start dashes are the end dashes (2)"
    ),
    ok.

-spec test_html_flow_case_29(Config) -> markdown_test:testcase() when
    Config :: ct_suite:ct_config().
test_html_flow_case_29(_Config) ->
    ?assertMatch(
        {ok, <<"<!---->"/utf8>>},
        markdown:to_html_with_options(<<"<!---->"/utf8>>, ?danger),
        "should support empty comments"
    ),
    ok.

-spec test_html_flow_case_30(Config) -> markdown_test:testcase() when
    Config :: ct_suite:ct_config().
test_html_flow_case_30(_Config) ->
    %% If the `\"` is encoded, we’re in text. If it remains, we’re in HTML.
    ?assertMatch(
        {ok, <<"<!--\n->\n\""/utf8>>},
        markdown:to_html_with_options(<<"<!--\n->\n\""/utf8>>, ?danger),
        "should not end a comment at one dash (`->`)"
    ),
    ok.

-spec test_html_flow_case_31(Config) -> markdown_test:testcase() when
    Config :: ct_suite:ct_config().
test_html_flow_case_31(_Config) ->
    ?assertMatch(
        {ok, <<"<!--\n-->\n<p>&quot;</p>"/utf8>>},
        markdown:to_html_with_options(<<"<!--\n-->\n\""/utf8>>, ?danger),
        "should end a comment at two dashes (`-->`)"
    ),
    ok.

-spec test_html_flow_case_32(Config) -> markdown_test:testcase() when
    Config :: ct_suite:ct_config().
test_html_flow_case_32(_Config) ->
    ?assertMatch(
        {ok, <<"<!--\n--->\n<p>&quot;</p>"/utf8>>},
        markdown:to_html_with_options(<<"<!--\n--->\n\""/utf8>>, ?danger),
        "should end a comment at three dashes (`--->`)"
    ),
    ok.

-spec test_html_flow_case_33(Config) -> markdown_test:testcase() when
    Config :: ct_suite:ct_config().
test_html_flow_case_33(_Config) ->
    ?assertMatch(
        {ok, <<"<!--\n---->\n<p>&quot;</p>"/utf8>>},
        markdown:to_html_with_options(<<"<!--\n---->\n\""/utf8>>, ?danger),
        "should end a comment at four dashes (`---->`)"
    ),
    ok.

-spec test_html_flow_case_34(Config) -> markdown_test:testcase() when
    Config :: ct_suite:ct_config().
test_html_flow_case_34(_Config) ->
    ?assertMatch(
        {ok, <<"  <!-- foo -->"/utf8>>},
        markdown:to_html_with_options(<<"  <!-- foo -->"/utf8>>, ?danger),
        "should support comments w/ indent"
    ),
    ok.

-spec test_html_flow_case_35(Config) -> markdown_test:testcase() when
    Config :: ct_suite:ct_config().
test_html_flow_case_35(_Config) ->
    ?assertMatch(
        {ok, <<"<pre><code>&lt;!-- foo --&gt;\n</code></pre>"/utf8>>},
        markdown:to_html_with_options(<<"    <!-- foo -->"/utf8>>, ?danger),
        "should not support comments w/ a 4 character indent"
    ),
    ok.

-spec test_html_flow_case_36(Config) -> markdown_test:testcase() when
    Config :: ct_suite:ct_config().
test_html_flow_case_36(_Config) ->
    %% Extra.
    ?assertMatch(
        {ok, <<"<p>Foo</p>\n<!--"/utf8>>},
        markdown:to_html_with_options(<<"Foo\n<!--"/utf8>>, ?danger),
        "should support interrupting paragraphs w/ comments"
    ),
    ok.

-spec test_html_flow_case_37(Config) -> markdown_test:testcase() when
    Config :: ct_suite:ct_config().
test_html_flow_case_37(_Config) ->
    ?assertMatch(
        {ok, <<"<!--\n  \n  \n-->"/utf8>>},
        markdown:to_html_with_options(<<"<!--\n  \n  \n-->"/utf8>>, ?danger),
        "should support blank lines in comments"
    ),
    ok.

-spec test_html_flow_case_38(Config) -> markdown_test:testcase() when
    Config :: ct_suite:ct_config().
test_html_flow_case_38(_Config) ->
    ?assertMatch(
        {ok, <<"<blockquote>\n<!--\n</blockquote>\n<p>a</p>"/utf8>>},
        markdown:to_html_with_options(<<"> <!--\na"/utf8>>, ?danger),
        "should not support lazyness (1)"
    ),
    ok.

-spec test_html_flow_case_39(Config) -> markdown_test:testcase() when
    Config :: ct_suite:ct_config().
test_html_flow_case_39(_Config) ->
    ?assertMatch(
        {ok, <<"<blockquote>\n<p>a</p>\n</blockquote>\n<!--"/utf8>>},
        markdown:to_html_with_options(<<"> a\n<!--"/utf8>>, ?danger),
        "should not support lazyness (2)"
    ),
    ok.

-spec test_html_flow_case_40(Config) -> markdown_test:testcase() when
    Config :: ct_suite:ct_config().
test_html_flow_case_40(_Config) ->
    ?assertMatch(
        {ok, <<"<?php\n\n  echo \">\";\n\n?>\n<p>okay</p>"/utf8>>},
        markdown:to_html_with_options(<<"<?php\n\n  echo \">\";\n\n?>\nokay"/utf8>>, ?danger),
        "should support instructions (type 3)"
    ),
    ok.

-spec test_html_flow_case_41(Config) -> markdown_test:testcase() when
    Config :: ct_suite:ct_config().
test_html_flow_case_41(_Config) ->
    ?assertMatch(
        {ok, <<"<?>"/utf8>>},
        markdown:to_html_with_options(<<"<?>"/utf8>>, ?danger),
        "should support empty instructions where the `?` is part of both the start and the end"
    ),
    ok.

-spec test_html_flow_case_42(Config) -> markdown_test:testcase() when
    Config :: ct_suite:ct_config().
test_html_flow_case_42(_Config) ->
    ?assertMatch(
        {ok, <<"<??>"/utf8>>},
        markdown:to_html_with_options(<<"<??>"/utf8>>, ?danger),
        "should support empty instructions"
    ),
    ok.

-spec test_html_flow_case_43(Config) -> markdown_test:testcase() when
    Config :: ct_suite:ct_config().
test_html_flow_case_43(_Config) ->
    %% Extra.
    ?assertMatch(
        {ok, <<"<p>Foo</p>\n<?"/utf8>>},
        markdown:to_html_with_options(<<"Foo\n<?"/utf8>>, ?danger),
        "should support interrupting paragraphs w/ instructions"
    ),
    ok.

-spec test_html_flow_case_44(Config) -> markdown_test:testcase() when
    Config :: ct_suite:ct_config().
test_html_flow_case_44(_Config) ->
    ?assertMatch(
        {ok, <<"<?\n  \n  \n?>"/utf8>>},
        markdown:to_html_with_options(<<"<?\n  \n  \n?>"/utf8>>, ?danger),
        "should support blank lines in instructions"
    ),
    ok.

-spec test_html_flow_case_45(Config) -> markdown_test:testcase() when
    Config :: ct_suite:ct_config().
test_html_flow_case_45(_Config) ->
    ?assertMatch(
        {ok, <<"<blockquote>\n<?\n</blockquote>\n<p>a</p>"/utf8>>},
        markdown:to_html_with_options(<<"> <?\na"/utf8>>, ?danger),
        "should not support lazyness (1)"
    ),
    ok.

-spec test_html_flow_case_46(Config) -> markdown_test:testcase() when
    Config :: ct_suite:ct_config().
test_html_flow_case_46(_Config) ->
    ?assertMatch(
        {ok, <<"<blockquote>\n<p>a</p>\n</blockquote>\n<?"/utf8>>},
        markdown:to_html_with_options(<<"> a\n<?"/utf8>>, ?danger),
        "should not support lazyness (2)"
    ),
    ok.

-spec test_html_flow_case_47(Config) -> markdown_test:testcase() when
    Config :: ct_suite:ct_config().
test_html_flow_case_47(_Config) ->
    ?assertMatch(
        {ok, <<"<!DOCTYPE html>"/utf8>>},
        markdown:to_html_with_options(<<"<!DOCTYPE html>"/utf8>>, ?danger),
        "should support declarations (type 4)"
    ),
    ok.

-spec test_html_flow_case_48(Config) -> markdown_test:testcase() when
    Config :: ct_suite:ct_config().
test_html_flow_case_48(_Config) ->
    ?assertMatch(
        {ok, <<"<p>&lt;!123&gt;</p>"/utf8>>},
        markdown:to_html_with_options(<<"<!123>"/utf8>>, ?danger),
        "should not support declarations that start w/o an alpha"
    ),
    ok.

-spec test_html_flow_case_49(Config) -> markdown_test:testcase() when
    Config :: ct_suite:ct_config().
test_html_flow_case_49(_Config) ->
    ?assertMatch(
        {ok, <<"<p>&lt;!&gt;</p>"/utf8>>},
        markdown:to_html_with_options(<<"<!>"/utf8>>, ?danger),
        "should not support declarations w/o an identifier"
    ),
    ok.

-spec test_html_flow_case_50(Config) -> markdown_test:testcase() when
    Config :: ct_suite:ct_config().
test_html_flow_case_50(_Config) ->
    ?assertMatch(
        {ok, <<"<!a>"/utf8>>},
        markdown:to_html_with_options(<<"<!a>"/utf8>>, ?danger),
        "should support declarations w/o a single alpha as identifier"
    ),
    ok.

-spec test_html_flow_case_51(Config) -> markdown_test:testcase() when
    Config :: ct_suite:ct_config().
test_html_flow_case_51(_Config) ->
    %% Extra.
    ?assertMatch(
        {ok, <<"<p>Foo</p>\n<!d"/utf8>>},
        markdown:to_html_with_options(<<"Foo\n<!d"/utf8>>, ?danger),
        "should support interrupting paragraphs w/ declarations"
    ),
    ok.

-spec test_html_flow_case_52(Config) -> markdown_test:testcase() when
    Config :: ct_suite:ct_config().
test_html_flow_case_52(_Config) ->
    %% Note about the lower letter: <https://github.com/commonmark/commonmark-spec/pull/621>
    ?assertMatch(
        {ok, <<"<!a\n  \n  \n>"/utf8>>},
        markdown:to_html_with_options(<<"<!a\n  \n  \n>"/utf8>>, ?danger),
        "should support blank lines in declarations"
    ),
    ok.

-spec test_html_flow_case_53(Config) -> markdown_test:testcase() when
    Config :: ct_suite:ct_config().
test_html_flow_case_53(_Config) ->
    ?assertMatch(
        {ok, <<"<blockquote>\n<!a\n</blockquote>\n<p>b</p>"/utf8>>},
        markdown:to_html_with_options(<<"> <!a\nb"/utf8>>, ?danger),
        "should not support lazyness (1)"
    ),
    ok.

-spec test_html_flow_case_54(Config) -> markdown_test:testcase() when
    Config :: ct_suite:ct_config().
test_html_flow_case_54(_Config) ->
    ?assertMatch(
        {ok, <<"<blockquote>\n<p>a</p>\n</blockquote>\n<!b"/utf8>>},
        markdown:to_html_with_options(<<"> a\n<!b"/utf8>>, ?danger),
        "should not support lazyness (2)"
    ),
    ok.

-spec test_html_flow_case_55(Config) -> markdown_test:testcase() when
    Config :: ct_suite:ct_config().
test_html_flow_case_55(_Config) ->
    ?assertMatch(
        {ok, <<"""
        <![CDATA[
        function matchwo(a,b)
        {
          if (a < b && a < 0) then {
            return 1;

          } else {

            return 0;
          }
        }
        ]]>
        <p>okay</p>
        """/utf8>>},
        markdown:to_html_with_options(
            <<"<![CDATA[\nfunction matchwo(a,b)\n{\n  if (a < b && a < 0) then {\n    return 1;\n\n  } else {\n\n    return 0;\n  }\n}\n]]>\nokay"/utf8>>,
            ?danger
        ),
        "should support cdata (type 5)"
    ),
    ok.

-spec test_html_flow_case_56(Config) -> markdown_test:testcase() when
    Config :: ct_suite:ct_config().
test_html_flow_case_56(_Config) ->
    ?assertMatch(
        {ok, <<"<![CDATA[]]>"/utf8>>},
        markdown:to_html_with_options(<<"<![CDATA[]]>"/utf8>>, ?danger),
        "should support empty cdata"
    ),
    ok.

-spec test_html_flow_case_57(Config) -> markdown_test:testcase() when
    Config :: ct_suite:ct_config().
test_html_flow_case_57(_Config) ->
    ?assertMatch(
        {ok, <<"<p>&lt;![CDATA]]&gt;</p>"/utf8>>},
        markdown:to_html_with_options(<<"<![CDATA]]>"/utf8>>, ?danger),
        "should not support cdata w/ a missing `[`"
    ),
    ok.

-spec test_html_flow_case_58(Config) -> markdown_test:testcase() when
    Config :: ct_suite:ct_config().
test_html_flow_case_58(_Config) ->
    ?assertMatch(
        {ok, <<"<![CDATA[]]]>"/utf8>>},
        markdown:to_html_with_options(<<"<![CDATA[]]]>"/utf8>>, ?danger),
        "should support cdata w/ a single `]` as content"
    ),
    ok.

-spec test_html_flow_case_59(Config) -> markdown_test:testcase() when
    Config :: ct_suite:ct_config().
test_html_flow_case_59(_Config) ->
    %% Extra.
    ?assertMatch(
        {ok, <<"<p>Foo</p>\n<![CDATA["/utf8>>},
        markdown:to_html_with_options(<<"Foo\n<![CDATA["/utf8>>, ?danger),
        "should support interrupting paragraphs w/ cdata"
    ),
    ok.

-spec test_html_flow_case_60(Config) -> markdown_test:testcase() when
    Config :: ct_suite:ct_config().
test_html_flow_case_60(_Config) ->
    %% Note: cmjs parses this differently. See: <https://github.com/commonmark/commonmark.js/issues/193>
    ?assertMatch(
        {ok, <<"<p>&lt;![cdata[]]&gt;</p>"/utf8>>},
        markdown:to_html_with_options(<<"<![cdata[]]>"/utf8>>, ?danger),
        "should not support lowercase cdata"
    ),
    ok.

-spec test_html_flow_case_61(Config) -> markdown_test:testcase() when
    Config :: ct_suite:ct_config().
test_html_flow_case_61(_Config) ->
    ?assertMatch(
        {ok, <<"<![CDATA[\n  \n  \n]]>"/utf8>>},
        markdown:to_html_with_options(<<"<![CDATA[\n  \n  \n]]>"/utf8>>, ?danger),
        "should support blank lines in cdata"
    ),
    ok.

-spec test_html_flow_case_62(Config) -> markdown_test:testcase() when
    Config :: ct_suite:ct_config().
test_html_flow_case_62(_Config) ->
    ?assertMatch(
        {ok, <<"<blockquote>\n<![CDATA[\n</blockquote>\n<p>a</p>"/utf8>>},
        markdown:to_html_with_options(<<"> <![CDATA[\na"/utf8>>, ?danger),
        "should not support lazyness (1)"
    ),
    ok.

-spec test_html_flow_case_63(Config) -> markdown_test:testcase() when
    Config :: ct_suite:ct_config().
test_html_flow_case_63(_Config) ->
    ?assertMatch(
        {ok, <<"<blockquote>\n<p>a</p>\n</blockquote>\n<![CDATA["/utf8>>},
        markdown:to_html_with_options(<<"> a\n<![CDATA["/utf8>>, ?danger),
        "should not support lazyness (2)"
    ),
    ok.

-spec test_html_flow_case_64(Config) -> markdown_test:testcase() when
    Config :: ct_suite:ct_config().
test_html_flow_case_64(_Config) ->
    ?assertMatch(
        {ok, <<"<table><tr><td>\n<pre>\n**Hello**,\n<p><em>world</em>.\n</pre></p>\n</td></tr></table>"/utf8>>},
        markdown:to_html_with_options(
            <<"<table><tr><td>\n<pre>\n**Hello**,\n\n_world_.\n</pre>\n</td></tr></table>"/utf8>>, ?danger
        ),
        "should support html (basic)"
    ),
    ok.

-spec test_html_flow_case_65(Config) -> markdown_test:testcase() when
    Config :: ct_suite:ct_config().
test_html_flow_case_65(_Config) ->
    ?assertMatch(
        {ok, <<"<table>\n  <tr>\n    <td>\n           hi\n    </td>\n  </tr>\n</table>\n<p>okay.</p>"/utf8>>},
        markdown:to_html_with_options(
            <<"<table>\n  <tr>\n    <td>\n           hi\n    </td>\n  </tr>\n</table>\n\nokay."/utf8>>, ?danger
        ),
        "should support html of type 6 (1)"
    ),
    ok.

-spec test_html_flow_case_66(Config) -> markdown_test:testcase() when
    Config :: ct_suite:ct_config().
test_html_flow_case_66(_Config) ->
    ?assertMatch(
        {ok, <<" <div>\n  *hello*\n         <foo><a>"/utf8>>},
        markdown:to_html_with_options(<<" <div>\n  *hello*\n         <foo><a>"/utf8>>, ?danger),
        "should support html of type 6 (2)"
    ),
    ok.

-spec test_html_flow_case_67(Config) -> markdown_test:testcase() when
    Config :: ct_suite:ct_config().
test_html_flow_case_67(_Config) ->
    ?assertMatch(
        {ok, <<"</div>\n*foo*"/utf8>>},
        markdown:to_html_with_options(<<"</div>\n*foo*"/utf8>>, ?danger),
        "should support html starting w/ a closing tag"
    ),
    ok.

-spec test_html_flow_case_68(Config) -> markdown_test:testcase() when
    Config :: ct_suite:ct_config().
test_html_flow_case_68(_Config) ->
    ?assertMatch(
        {ok, <<"<DIV CLASS=\"foo\">\n<p><em>Markdown</em></p>\n</DIV>"/utf8>>},
        markdown:to_html_with_options(<<"<DIV CLASS=\"foo\">\n\n*Markdown*\n\n</DIV>"/utf8>>, ?danger),
        "should support html w/ markdown in between"
    ),
    ok.

-spec test_html_flow_case_69(Config) -> markdown_test:testcase() when
    Config :: ct_suite:ct_config().
test_html_flow_case_69(_Config) ->
    ?assertMatch(
        {ok, <<"<div id=\"foo\"\n  class=\"bar\">\n</div>"/utf8>>},
        markdown:to_html_with_options(<<"<div id=\"foo\"\n  class=\"bar\">\n</div>"/utf8>>, ?danger),
        "should support html w/ line endings (1)"
    ),
    ok.

-spec test_html_flow_case_70(Config) -> markdown_test:testcase() when
    Config :: ct_suite:ct_config().
test_html_flow_case_70(_Config) ->
    ?assertMatch(
        {ok, <<"<div id=\"foo\" class=\"bar\n  baz\">\n</div>"/utf8>>},
        markdown:to_html_with_options(<<"<div id=\"foo\" class=\"bar\n  baz\">\n</div>"/utf8>>, ?danger),
        "should support html w/ line endings (2)"
    ),
    ok.

-spec test_html_flow_case_71(Config) -> markdown_test:testcase() when
    Config :: ct_suite:ct_config().
test_html_flow_case_71(_Config) ->
    ?assertMatch(
        {ok, <<"<div>\n*foo*\n<p><em>bar</em></p>"/utf8>>},
        markdown:to_html_with_options(<<"<div>\n*foo*\n\n*bar*"/utf8>>, ?danger),
        "should support an unclosed html element"
    ),
    ok.

-spec test_html_flow_case_72(Config) -> markdown_test:testcase() when
    Config :: ct_suite:ct_config().
test_html_flow_case_72(_Config) ->
    ?assertMatch(
        {ok, <<"<div id=\"foo\"\n*hi*"/utf8>>},
        markdown:to_html_with_options(<<"<div id=\"foo\"\n*hi*"/utf8>>, ?danger),
        "should support garbage html (1)"
    ),
    ok.

-spec test_html_flow_case_73(Config) -> markdown_test:testcase() when
    Config :: ct_suite:ct_config().
test_html_flow_case_73(_Config) ->
    ?assertMatch(
        {ok, <<"<div class\nfoo"/utf8>>},
        markdown:to_html_with_options(<<"<div class\nfoo"/utf8>>, ?danger),
        "should support garbage html (2)"
    ),
    ok.

-spec test_html_flow_case_74(Config) -> markdown_test:testcase() when
    Config :: ct_suite:ct_config().
test_html_flow_case_74(_Config) ->
    ?assertMatch(
        {ok, <<"<div *???-&&&-<---\n*foo*"/utf8>>},
        markdown:to_html_with_options(<<"<div *???-&&&-<---\n*foo*"/utf8>>, ?danger),
        "should support garbage html (3)"
    ),
    ok.

-spec test_html_flow_case_75(Config) -> markdown_test:testcase() when
    Config :: ct_suite:ct_config().
test_html_flow_case_75(_Config) ->
    ?assertMatch(
        {ok, <<"<div><a href=\"bar\">*foo*</a></div>"/utf8>>},
        markdown:to_html_with_options(<<"<div><a href=\"bar\">*foo*</a></div>"/utf8>>, ?danger),
        "should support other tags in the opening (1)"
    ),
    ok.

-spec test_html_flow_case_76(Config) -> markdown_test:testcase() when
    Config :: ct_suite:ct_config().
test_html_flow_case_76(_Config) ->
    ?assertMatch(
        {ok, <<"<table><tr><td>\nfoo\n</td></tr></table>"/utf8>>},
        markdown:to_html_with_options(<<"<table><tr><td>\nfoo\n</td></tr></table>"/utf8>>, ?danger),
        "should support other tags in the opening (2)"
    ),
    ok.

-spec test_html_flow_case_77(Config) -> markdown_test:testcase() when
    Config :: ct_suite:ct_config().
test_html_flow_case_77(_Config) ->
    ?assertMatch(
        {ok, <<"<div></div>\n``` c\nint x = 33;\n```"/utf8>>},
        markdown:to_html_with_options(<<"<div></div>\n``` c\nint x = 33;\n```"/utf8>>, ?danger),
        "should include everything ’till a blank line"
    ),
    ok.

-spec test_html_flow_case_78(Config) -> markdown_test:testcase() when
    Config :: ct_suite:ct_config().
test_html_flow_case_78(_Config) ->
    ?assertMatch(
        {ok, <<"<blockquote>\n<div>\nfoo\n</blockquote>\n<p>bar</p>"/utf8>>},
        markdown:to_html_with_options(<<"> <div>\n> foo\n\nbar"/utf8>>, ?danger),
        "should support basic tags w/o ending in containers (1)"
    ),
    ok.

-spec test_html_flow_case_79(Config) -> markdown_test:testcase() when
    Config :: ct_suite:ct_config().
test_html_flow_case_79(_Config) ->
    ?assertMatch(
        {ok, <<"<ul>\n<li>\n<div>\n</li>\n<li>foo</li>\n</ul>"/utf8>>},
        markdown:to_html_with_options(<<"- <div>\n- foo"/utf8>>, ?danger),
        "should support basic tags w/o ending in containers (2)"
    ),
    ok.

-spec test_html_flow_case_80(Config) -> markdown_test:testcase() when
    Config :: ct_suite:ct_config().
test_html_flow_case_80(_Config) ->
    ?assertMatch(
        {ok, <<"  <div>"/utf8>>},
        markdown:to_html_with_options(<<"  <div>"/utf8>>, ?danger),
        "should support basic tags w/ indent"
    ),
    ok.

-spec test_html_flow_case_81(Config) -> markdown_test:testcase() when
    Config :: ct_suite:ct_config().
test_html_flow_case_81(_Config) ->
    ?assertMatch(
        {ok, <<"<pre><code>&lt;div&gt;\n</code></pre>"/utf8>>},
        markdown:to_html_with_options(<<"    <div>"/utf8>>, ?danger),
        "should not support basic tags w/ a 4 character indent"
    ),
    ok.

-spec test_html_flow_case_82(Config) -> markdown_test:testcase() when
    Config :: ct_suite:ct_config().
test_html_flow_case_82(_Config) ->
    ?assertMatch(
        {ok, <<"<p>Foo</p>\n<div>\nbar\n</div>"/utf8>>},
        markdown:to_html_with_options(<<"Foo\n<div>\nbar\n</div>"/utf8>>, ?danger),
        "should support interrupting paragraphs w/ basic tags"
    ),
    ok.

-spec test_html_flow_case_83(Config) -> markdown_test:testcase() when
    Config :: ct_suite:ct_config().
test_html_flow_case_83(_Config) ->
    ?assertMatch(
        {ok, <<"<div>\nbar\n</div>\n*foo*"/utf8>>},
        markdown:to_html_with_options(<<"<div>\nbar\n</div>\n*foo*"/utf8>>, ?danger),
        "should require a blank line to end"
    ),
    ok.

-spec test_html_flow_case_84(Config) -> markdown_test:testcase() when
    Config :: ct_suite:ct_config().
test_html_flow_case_84(_Config) ->
    ?assertMatch(
        {ok, <<"<div>\n<p><em>Emphasized</em> text.</p>\n</div>"/utf8>>},
        markdown:to_html_with_options(<<"<div>\n\n*Emphasized* text.\n\n</div>"/utf8>>, ?danger),
        "should support interleaving w/ blank lines"
    ),
    ok.

-spec test_html_flow_case_85(Config) -> markdown_test:testcase() when
    Config :: ct_suite:ct_config().
test_html_flow_case_85(_Config) ->
    ?assertMatch(
        {ok, <<"<div>\n*Emphasized* text.\n</div>"/utf8>>},
        markdown:to_html_with_options(<<"<div>\n*Emphasized* text.\n</div>"/utf8>>, ?danger),
        "should not support interleaving w/o blank lines"
    ),
    ok.

-spec test_html_flow_case_86(Config) -> markdown_test:testcase() when
    Config :: ct_suite:ct_config().
test_html_flow_case_86(_Config) ->
    ?assertMatch(
        {ok, <<"<table>\n<tr>\n<td>\nHi\n</td>\n</tr>\n</table>"/utf8>>},
        markdown:to_html_with_options(<<"<table>\n\n<tr>\n\n<td>\nHi\n</td>\n\n</tr>\n\n</table>"/utf8>>, ?danger),
        "should support blank lines between adjacent html"
    ),
    ok.

-spec test_html_flow_case_87(Config) -> markdown_test:testcase() when
    Config :: ct_suite:ct_config().
test_html_flow_case_87(_Config) ->
    ?assertMatch(
        {ok, <<"<table>\n  <tr>\n<pre><code>&lt;td&gt;\n  Hi\n&lt;/td&gt;\n</code></pre>\n  </tr>\n</table>"/utf8>>},
        markdown:to_html_with_options(
            <<"<table>\n\n  <tr>\n\n    <td>\n      Hi\n    </td>\n\n  </tr>\n\n</table>"/utf8>>, ?danger
        ),
        "should not support indented, blank-line delimited, adjacent html"
    ),
    ok.

-spec test_html_flow_case_88(Config) -> markdown_test:testcase() when
    Config :: ct_suite:ct_config().
test_html_flow_case_88(_Config) ->
    ?assertMatch(
        {ok, <<"<p>&lt;/1&gt;</p>"/utf8>>},
        markdown:to_html_with_options(<<"</1>"/utf8>>, ?danger),
        "should not support basic tags w/ an incorrect name start character"
    ),
    ok.

-spec test_html_flow_case_89(Config) -> markdown_test:testcase() when
    Config :: ct_suite:ct_config().
test_html_flow_case_89(_Config) ->
    ?assertMatch(
        {ok, <<"<div"/utf8>>},
        markdown:to_html_with_options(<<"<div"/utf8>>, ?danger),
        "should support an eof directly after a basic tag name"
    ),
    ok.

-spec test_html_flow_case_90(Config) -> markdown_test:testcase() when
    Config :: ct_suite:ct_config().
test_html_flow_case_90(_Config) ->
    ?assertMatch(
        {ok, <<"<div\n"/utf8>>},
        markdown:to_html_with_options(<<"<div\n"/utf8>>, ?danger),
        "should support a line ending directly after a tag name"
    ),
    ok.

-spec test_html_flow_case_91(Config) -> markdown_test:testcase() when
    Config :: ct_suite:ct_config().
test_html_flow_case_91(_Config) ->
    ?assertMatch(
        {ok, <<"<div "/utf8>>},
        markdown:to_html_with_options(<<"<div "/utf8>>, ?danger),
        "should support an eof after a space directly after a tag name"
    ),
    ok.

-spec test_html_flow_case_92(Config) -> markdown_test:testcase() when
    Config :: ct_suite:ct_config().
test_html_flow_case_92(_Config) ->
    ?assertMatch(
        {ok, <<"<p>&lt;div/</p>"/utf8>>},
        markdown:to_html_with_options(<<"<div/"/utf8>>, ?danger),
        "should not support an eof directly after a self-closing slash"
    ),
    ok.

-spec test_html_flow_case_93(Config) -> markdown_test:testcase() when
    Config :: ct_suite:ct_config().
test_html_flow_case_93(_Config) ->
    ?assertMatch(
        {ok, <<"<p>&lt;div/\n<em>asd</em></p>"/utf8>>},
        markdown:to_html_with_options(<<"<div/\n*asd*"/utf8>>, ?danger),
        "should not support a line ending after a self-closing slash"
    ),
    ok.

-spec test_html_flow_case_94(Config) -> markdown_test:testcase() when
    Config :: ct_suite:ct_config().
test_html_flow_case_94(_Config) ->
    ?assertMatch(
        {ok, <<"<div/>"/utf8>>},
        markdown:to_html_with_options(<<"<div/>"/utf8>>, ?danger),
        "should support an eof after a self-closing tag"
    ),
    ok.

-spec test_html_flow_case_95(Config) -> markdown_test:testcase() when
    Config :: ct_suite:ct_config().
test_html_flow_case_95(_Config) ->
    ?assertMatch(
        {ok, <<"<div/>\na"/utf8>>},
        markdown:to_html_with_options(<<"<div/>\na"/utf8>>, ?danger),
        "should support a line ending after a self-closing tag"
    ),
    ok.

-spec test_html_flow_case_96(Config) -> markdown_test:testcase() when
    Config :: ct_suite:ct_config().
test_html_flow_case_96(_Config) ->
    ?assertMatch(
        {ok, <<"<div/>a"/utf8>>},
        markdown:to_html_with_options(<<"<div/>a"/utf8>>, ?danger),
        "should support another character after a self-closing tag"
    ),
    ok.

-spec test_html_flow_case_97(Config) -> markdown_test:testcase() when
    Config :: ct_suite:ct_config().
test_html_flow_case_97(_Config) ->
    ?assertMatch(
        {ok, <<"<div>a"/utf8>>},
        markdown:to_html_with_options(<<"<div>a"/utf8>>, ?danger),
        "should support another character after a basic opening tag"
    ),
    ok.

-spec test_html_flow_case_98(Config) -> markdown_test:testcase() when
    Config :: ct_suite:ct_config().
test_html_flow_case_98(_Config) ->
    %% Extra.
    ?assertMatch(
        {ok, <<"<p>Foo</p>\n<div/>"/utf8>>},
        markdown:to_html_with_options(<<"Foo\n<div/>"/utf8>>, ?danger),
        "should support interrupting paragraphs w/ self-closing basic tags"
    ),
    ok.

-spec test_html_flow_case_99(Config) -> markdown_test:testcase() when
    Config :: ct_suite:ct_config().
test_html_flow_case_99(_Config) ->
    ?assertMatch(
        {ok, <<"<div\n<blockquote>\n</blockquote>"/utf8>>},
        markdown:to_html_with_options(<<"<div\n  \n  \n>"/utf8>>, ?danger),
        "should not support blank lines in basic"
    ),
    ok.

-spec test_html_flow_case_100(Config) -> markdown_test:testcase() when
    Config :: ct_suite:ct_config().
test_html_flow_case_100(_Config) ->
    ?assertMatch(
        {ok, <<"<blockquote>\n<div\n</blockquote>\n<p>a</p>"/utf8>>},
        markdown:to_html_with_options(<<"> <div\na"/utf8>>, ?danger),
        "should not support lazyness (1)"
    ),
    ok.

-spec test_html_flow_case_101(Config) -> markdown_test:testcase() when
    Config :: ct_suite:ct_config().
test_html_flow_case_101(_Config) ->
    ?assertMatch(
        {ok, <<"<blockquote>\n<p>a</p>\n</blockquote>\n<div"/utf8>>},
        markdown:to_html_with_options(<<"> a\n<div"/utf8>>, ?danger),
        "should not support lazyness (2)"
    ),
    ok.

-spec test_html_flow_case_102(Config) -> markdown_test:testcase() when
    Config :: ct_suite:ct_config().
test_html_flow_case_102(_Config) ->
    ?assertMatch(
        {ok, <<"<a href=\"foo\">\n*bar*\n</a>"/utf8>>},
        markdown:to_html_with_options(<<"<a href=\"foo\">\n*bar*\n</a>"/utf8>>, ?danger),
        "should support complete tags (type 7)"
    ),
    ok.

-spec test_html_flow_case_103(Config) -> markdown_test:testcase() when
    Config :: ct_suite:ct_config().
test_html_flow_case_103(_Config) ->
    ?assertMatch(
        {ok, <<"<Warning>\n*bar*\n</Warning>"/utf8>>},
        markdown:to_html_with_options(<<"<Warning>\n*bar*\n</Warning>"/utf8>>, ?danger),
        "should support non-html tag names"
    ),
    ok.

-spec test_html_flow_case_104(Config) -> markdown_test:testcase() when
    Config :: ct_suite:ct_config().
test_html_flow_case_104(_Config) ->
    ?assertMatch(
        {ok, <<"<i class=\"foo\">\n*bar*\n</i>"/utf8>>},
        markdown:to_html_with_options(<<"<i class=\"foo\">\n*bar*\n</i>"/utf8>>, ?danger),
        "should support non-“block” html tag names (1)"
    ),
    ok.

-spec test_html_flow_case_105(Config) -> markdown_test:testcase() when
    Config :: ct_suite:ct_config().
test_html_flow_case_105(_Config) ->
    ?assertMatch(
        {ok, <<"<del>\n*foo*\n</del>"/utf8>>},
        markdown:to_html_with_options(<<"<del>\n*foo*\n</del>"/utf8>>, ?danger),
        "should support non-“block” html tag names (2)"
    ),
    ok.

-spec test_html_flow_case_106(Config) -> markdown_test:testcase() when
    Config :: ct_suite:ct_config().
test_html_flow_case_106(_Config) ->
    ?assertMatch(
        {ok, <<"</ins>\n*bar*"/utf8>>},
        markdown:to_html_with_options(<<"</ins>\n*bar*"/utf8>>, ?danger),
        "should support closing tags"
    ),
    ok.

-spec test_html_flow_case_107(Config) -> markdown_test:testcase() when
    Config :: ct_suite:ct_config().
test_html_flow_case_107(_Config) ->
    ?assertMatch(
        {ok, <<"<del>\n<p><em>foo</em></p>\n</del>"/utf8>>},
        markdown:to_html_with_options(<<"<del>\n\n*foo*\n\n</del>"/utf8>>, ?danger),
        "should support interleaving"
    ),
    ok.

-spec test_html_flow_case_108(Config) -> markdown_test:testcase() when
    Config :: ct_suite:ct_config().
test_html_flow_case_108(_Config) ->
    ?assertMatch(
        {ok, <<"<p><del><em>foo</em></del></p>"/utf8>>},
        markdown:to_html_with_options(<<"<del>*foo*</del>"/utf8>>, ?danger),
        "should not support interleaving w/o blank lines"
    ),
    ok.

-spec test_html_flow_case_109(Config) -> markdown_test:testcase() when
    Config :: ct_suite:ct_config().
test_html_flow_case_109(_Config) ->
    ?assertMatch(
        {ok, <<"<div>\n<p>asd</p>"/utf8>>},
        markdown:to_html_with_options(<<"<div>\n  \nasd"/utf8>>, ?danger),
        "should support interleaving w/ whitespace-only blank lines"
    ),
    ok.

-spec test_html_flow_case_110(Config) -> markdown_test:testcase() when
    Config :: ct_suite:ct_config().
test_html_flow_case_110(_Config) ->
    ?assertMatch(
        {ok, <<"<p>Foo\n<a href=\"bar\">\nbaz</p>"/utf8>>},
        markdown:to_html_with_options(<<"Foo\n<a href=\"bar\">\nbaz"/utf8>>, ?danger),
        "should not support interrupting paragraphs w/ complete tags"
    ),
    ok.

-spec test_html_flow_case_111(Config) -> markdown_test:testcase() when
    Config :: ct_suite:ct_config().
test_html_flow_case_111(_Config) ->
    ?assertMatch(
        {ok, <<"<p>&lt;x</p>"/utf8>>},
        markdown:to_html_with_options(<<"<x"/utf8>>, ?danger),
        "should not support an eof directly after a tag name"
    ),
    ok.

-spec test_html_flow_case_112(Config) -> markdown_test:testcase() when
    Config :: ct_suite:ct_config().
test_html_flow_case_112(_Config) ->
    ?assertMatch(
        {ok, <<"<p>&lt;x/</p>"/utf8>>},
        markdown:to_html_with_options(<<"<x/"/utf8>>, ?danger),
        "should not support an eof directly after a self-closing slash"
    ),
    ok.

-spec test_html_flow_case_113(Config) -> markdown_test:testcase() when
    Config :: ct_suite:ct_config().
test_html_flow_case_113(_Config) ->
    ?assertMatch(
        {ok, <<"<p>&lt;x</p>\n"/utf8>>},
        markdown:to_html_with_options(<<"<x\n"/utf8>>, ?danger),
        "should not support a line ending directly after a tag name"
    ),
    ok.

-spec test_html_flow_case_114(Config) -> markdown_test:testcase() when
    Config :: ct_suite:ct_config().
test_html_flow_case_114(_Config) ->
    ?assertMatch(
        {ok, <<"<p>&lt;x</p>"/utf8>>},
        markdown:to_html_with_options(<<"<x "/utf8>>, ?danger),
        "should not support an eof after a space directly after a tag name"
    ),
    ok.

-spec test_html_flow_case_115(Config) -> markdown_test:testcase() when
    Config :: ct_suite:ct_config().
test_html_flow_case_115(_Config) ->
    ?assertMatch(
        {ok, <<"<p>&lt;x/</p>"/utf8>>},
        markdown:to_html_with_options(<<"<x/"/utf8>>, ?danger),
        "should not support an eof directly after a self-closing slash"
    ),
    ok.

-spec test_html_flow_case_116(Config) -> markdown_test:testcase() when
    Config :: ct_suite:ct_config().
test_html_flow_case_116(_Config) ->
    ?assertMatch(
        {ok, <<"<p>&lt;x/\n<em>asd</em></p>"/utf8>>},
        markdown:to_html_with_options(<<"<x/\n*asd*"/utf8>>, ?danger),
        "should not support a line ending after a self-closing slash"
    ),
    ok.

-spec test_html_flow_case_117(Config) -> markdown_test:testcase() when
    Config :: ct_suite:ct_config().
test_html_flow_case_117(_Config) ->
    ?assertMatch(
        {ok, <<"<x/>"/utf8>>},
        markdown:to_html_with_options(<<"<x/>"/utf8>>, ?danger),
        "should support an eof after a self-closing tag"
    ),
    ok.

-spec test_html_flow_case_118(Config) -> markdown_test:testcase() when
    Config :: ct_suite:ct_config().
test_html_flow_case_118(_Config) ->
    ?assertMatch(
        {ok, <<"<x/>\na"/utf8>>},
        markdown:to_html_with_options(<<"<x/>\na"/utf8>>, ?danger),
        "should support a line ending after a self-closing tag"
    ),
    ok.

-spec test_html_flow_case_119(Config) -> markdown_test:testcase() when
    Config :: ct_suite:ct_config().
test_html_flow_case_119(_Config) ->
    ?assertMatch(
        {ok, <<"<p><x/>a</p>"/utf8>>},
        markdown:to_html_with_options(<<"<x/>a"/utf8>>, ?danger),
        "should not support another character after a self-closing tag"
    ),
    ok.

-spec test_html_flow_case_120(Config) -> markdown_test:testcase() when
    Config :: ct_suite:ct_config().
test_html_flow_case_120(_Config) ->
    ?assertMatch(
        {ok, <<"<p><x>a</p>"/utf8>>},
        markdown:to_html_with_options(<<"<x>a"/utf8>>, ?danger),
        "should not support another character after an opening tag"
    ),
    ok.

-spec test_html_flow_case_121(Config) -> markdown_test:testcase() when
    Config :: ct_suite:ct_config().
test_html_flow_case_121(_Config) ->
    ?assertMatch(
        {ok, <<"<x y>"/utf8>>},
        markdown:to_html_with_options(<<"<x y>"/utf8>>, ?danger),
        "should support boolean attributes in a complete tag"
    ),
    ok.

-spec test_html_flow_case_122(Config) -> markdown_test:testcase() when
    Config :: ct_suite:ct_config().
test_html_flow_case_122(_Config) ->
    ?assertMatch(
        {ok, <<"<p><x\ny></p>"/utf8>>},
        markdown:to_html_with_options(<<"<x\ny>"/utf8>>, ?danger),
        "should not support a line ending before an attribute name"
    ),
    ok.

-spec test_html_flow_case_123(Config) -> markdown_test:testcase() when
    Config :: ct_suite:ct_config().
test_html_flow_case_123(_Config) ->
    ?assertMatch(
        {ok, <<"<p><x\ny></p>"/utf8>>},
        markdown:to_html_with_options(<<"<x\n  y>"/utf8>>, ?danger),
        "should not support a line ending w/ whitespace before an attribute name"
    ),
    ok.

-spec test_html_flow_case_124(Config) -> markdown_test:testcase() when
    Config :: ct_suite:ct_config().
test_html_flow_case_124(_Config) ->
    ?assertMatch(
        {ok, <<"<p>&lt;x</p>\n<p>y&gt;</p>"/utf8>>},
        markdown:to_html_with_options(<<"<x\n  \ny>"/utf8>>, ?danger),
        "should not support a line ending w/ whitespace and another line ending before an attribute name"
    ),
    ok.

-spec test_html_flow_case_125(Config) -> markdown_test:testcase() when
    Config :: ct_suite:ct_config().
test_html_flow_case_125(_Config) ->
    ?assertMatch(
        {ok, <<"<p><x y\nz></p>"/utf8>>},
        markdown:to_html_with_options(<<"<x y\nz>"/utf8>>, ?danger),
        "should not support a line ending between attribute names"
    ),
    ok.

-spec test_html_flow_case_126(Config) -> markdown_test:testcase() when
    Config :: ct_suite:ct_config().
test_html_flow_case_126(_Config) ->
    ?assertMatch(
        {ok, <<"<x y   z>"/utf8>>},
        markdown:to_html_with_options(<<"<x y   z>"/utf8>>, ?danger),
        "should support whitespace between attribute names"
    ),
    ok.

-spec test_html_flow_case_127(Config) -> markdown_test:testcase() when
    Config :: ct_suite:ct_config().
test_html_flow_case_127(_Config) ->
    ?assertMatch(
        {ok, <<"<p>&lt;x:y&gt;</p>"/utf8>>},
        markdown:to_html_with_options(<<"<x:y>"/utf8>>, ?danger),
        "should not support a colon in a tag name"
    ),
    ok.

-spec test_html_flow_case_128(Config) -> markdown_test:testcase() when
    Config :: ct_suite:ct_config().
test_html_flow_case_128(_Config) ->
    ?assertMatch(
        {ok, <<"<p>&lt;x_y&gt;</p>"/utf8>>},
        markdown:to_html_with_options(<<"<x_y>"/utf8>>, ?danger),
        "should not support an underscore in a tag name"
    ),
    ok.

-spec test_html_flow_case_129(Config) -> markdown_test:testcase() when
    Config :: ct_suite:ct_config().
test_html_flow_case_129(_Config) ->
    ?assertMatch(
        {ok, <<"<p>&lt;x.y&gt;</p>"/utf8>>},
        markdown:to_html_with_options(<<"<x.y>"/utf8>>, ?danger),
        "should not support a dot in a tag name"
    ),
    ok.

-spec test_html_flow_case_130(Config) -> markdown_test:testcase() when
    Config :: ct_suite:ct_config().
test_html_flow_case_130(_Config) ->
    ?assertMatch(
        {ok, <<"<x :y>"/utf8>>},
        markdown:to_html_with_options(<<"<x :y>"/utf8>>, ?danger),
        "should support a colon to start an attribute name"
    ),
    ok.

-spec test_html_flow_case_131(Config) -> markdown_test:testcase() when
    Config :: ct_suite:ct_config().
test_html_flow_case_131(_Config) ->
    ?assertMatch(
        {ok, <<"<x _y>"/utf8>>},
        markdown:to_html_with_options(<<"<x _y>"/utf8>>, ?danger),
        "should support an underscore to start an attribute name"
    ),
    ok.

-spec test_html_flow_case_132(Config) -> markdown_test:testcase() when
    Config :: ct_suite:ct_config().
test_html_flow_case_132(_Config) ->
    ?assertMatch(
        {ok, <<"<p>&lt;x .y&gt;</p>"/utf8>>},
        markdown:to_html_with_options(<<"<x .y>"/utf8>>, ?danger),
        "should not support a dot to start an attribute name"
    ),
    ok.

-spec test_html_flow_case_133(Config) -> markdown_test:testcase() when
    Config :: ct_suite:ct_config().
test_html_flow_case_133(_Config) ->
    ?assertMatch(
        {ok, <<"<x y:>"/utf8>>},
        markdown:to_html_with_options(<<"<x y:>"/utf8>>, ?danger),
        "should support a colon to end an attribute name"
    ),
    ok.

-spec test_html_flow_case_134(Config) -> markdown_test:testcase() when
    Config :: ct_suite:ct_config().
test_html_flow_case_134(_Config) ->
    ?assertMatch(
        {ok, <<"<x y_>"/utf8>>},
        markdown:to_html_with_options(<<"<x y_>"/utf8>>, ?danger),
        "should support an underscore to end an attribute name"
    ),
    ok.

-spec test_html_flow_case_135(Config) -> markdown_test:testcase() when
    Config :: ct_suite:ct_config().
test_html_flow_case_135(_Config) ->
    ?assertMatch(
        {ok, <<"<x y.>"/utf8>>},
        markdown:to_html_with_options(<<"<x y.>"/utf8>>, ?danger),
        "should support a dot to end an attribute name"
    ),
    ok.

-spec test_html_flow_case_136(Config) -> markdown_test:testcase() when
    Config :: ct_suite:ct_config().
test_html_flow_case_136(_Config) ->
    ?assertMatch(
        {ok, <<"<x y123>"/utf8>>},
        markdown:to_html_with_options(<<"<x y123>"/utf8>>, ?danger),
        "should support numbers to end an attribute name"
    ),
    ok.

-spec test_html_flow_case_137(Config) -> markdown_test:testcase() when
    Config :: ct_suite:ct_config().
test_html_flow_case_137(_Config) ->
    ?assertMatch(
        {ok, <<"<x data->"/utf8>>},
        markdown:to_html_with_options(<<"<x data->"/utf8>>, ?danger),
        "should support a dash to end an attribute name"
    ),
    ok.

-spec test_html_flow_case_138(Config) -> markdown_test:testcase() when
    Config :: ct_suite:ct_config().
test_html_flow_case_138(_Config) ->
    ?assertMatch(
        {ok, <<"<p>&lt;x y=&gt;</p>"/utf8>>},
        markdown:to_html_with_options(<<"<x y=>"/utf8>>, ?danger),
        "should not upport an initializer w/o a value"
    ),
    ok.

-spec test_html_flow_case_139(Config) -> markdown_test:testcase() when
    Config :: ct_suite:ct_config().
test_html_flow_case_139(_Config) ->
    ?assertMatch(
        {ok, <<"<p>&lt;x y==&gt;</p>"/utf8>>},
        markdown:to_html_with_options(<<"<x y==>"/utf8>>, ?danger),
        "should not support an equals to as an initializer"
    ),
    ok.

-spec test_html_flow_case_140(Config) -> markdown_test:testcase() when
    Config :: ct_suite:ct_config().
test_html_flow_case_140(_Config) ->
    ?assertMatch(
        {ok, <<"<x y=z>"/utf8>>},
        markdown:to_html_with_options(<<"<x y=z>"/utf8>>, ?danger),
        "should support a single character as an unquoted attribute value"
    ),
    ok.

-spec test_html_flow_case_141(Config) -> markdown_test:testcase() when
    Config :: ct_suite:ct_config().
test_html_flow_case_141(_Config) ->
    ?assertMatch(
        {ok, <<"<x y=\"\">"/utf8>>},
        markdown:to_html_with_options(<<"<x y=\"\">"/utf8>>, ?danger),
        "should support an empty double quoted attribute value"
    ),
    ok.

-spec test_html_flow_case_142(Config) -> markdown_test:testcase() when
    Config :: ct_suite:ct_config().
test_html_flow_case_142(_Config) ->
    ?assertMatch(
        {ok, <<"<x y=\"\">"/utf8>>},
        markdown:to_html_with_options(<<"<x y=\"\">"/utf8>>, ?danger),
        "should support an empty single quoted attribute value"
    ),
    ok.

-spec test_html_flow_case_143(Config) -> markdown_test:testcase() when
    Config :: ct_suite:ct_config().
test_html_flow_case_143(_Config) ->
    ?assertMatch(
        {ok, <<"<p><x y=\"\n\"></p>"/utf8>>},
        markdown:to_html_with_options(<<"<x y=\"\n\">"/utf8>>, ?danger),
        "should not support a line ending in a double quoted attribute value"
    ),
    ok.

-spec test_html_flow_case_144(Config) -> markdown_test:testcase() when
    Config :: ct_suite:ct_config().
test_html_flow_case_144(_Config) ->
    ?assertMatch(
        {ok, <<"<p><x y=\"\n\"></p>"/utf8>>},
        markdown:to_html_with_options(<<"<x y=\"\n\">"/utf8>>, ?danger),
        "should not support a line ending in a single quoted attribute value"
    ),
    ok.

-spec test_html_flow_case_145(Config) -> markdown_test:testcase() when
    Config :: ct_suite:ct_config().
test_html_flow_case_145(_Config) ->
    ?assertMatch(
        {ok, <<"<p><w x=y\nz></p>"/utf8>>},
        markdown:to_html_with_options(<<"<w x=y\nz>"/utf8>>, ?danger),
        "should not support a line ending in/after an unquoted attribute value"
    ),
    ok.

-spec test_html_flow_case_146(Config) -> markdown_test:testcase() when
    Config :: ct_suite:ct_config().
test_html_flow_case_146(_Config) ->
    ?assertMatch(
        {ok, <<"<p>&lt;w x=y&quot;z&gt;</p>"/utf8>>},
        markdown:to_html_with_options(<<"<w x=y\"z>"/utf8>>, ?danger),
        "should not support a double quote in/after an unquoted attribute value"
    ),
    ok.

-spec test_html_flow_case_147(Config) -> markdown_test:testcase() when
    Config :: ct_suite:ct_config().
test_html_flow_case_147(_Config) ->
    ?assertMatch(
        {ok, <<"<p>&lt;w x=y'z&gt;</p>"/utf8>>},
        markdown:to_html_with_options(<<"<w x=y'z>"/utf8>>, ?danger),
        "should not support a single quote in/after an unquoted attribute value"
    ),
    ok.

-spec test_html_flow_case_148(Config) -> markdown_test:testcase() when
    Config :: ct_suite:ct_config().
test_html_flow_case_148(_Config) ->
    ?assertMatch(
        {ok, <<"<p>&lt;x y=&quot;&quot;z&gt;</p>"/utf8>>},
        markdown:to_html_with_options(<<"<x y=\"\"z>"/utf8>>, ?danger),
        "should not support an attribute after a double quoted attribute value"
    ),
    ok.

-spec test_html_flow_case_149(Config) -> markdown_test:testcase() when
    Config :: ct_suite:ct_config().
test_html_flow_case_149(_Config) ->
    ?assertMatch(
        {ok, <<"<x>\n<blockquote>\n</blockquote>"/utf8>>},
        markdown:to_html_with_options(<<"<x>\n  \n  \n>"/utf8>>, ?danger),
        "should not support blank lines in complete"
    ),
    ok.

-spec test_html_flow_case_150(Config) -> markdown_test:testcase() when
    Config :: ct_suite:ct_config().
test_html_flow_case_150(_Config) ->
    ?assertMatch(
        {ok, <<"<blockquote>\n<a>\n</blockquote>\n<p><em>bar</em></p>"/utf8>>},
        markdown:to_html_with_options(<<"> <a>\n*bar*"/utf8>>, ?danger),
        "should not support lazyness (1)"
    ),
    ok.

-spec test_html_flow_case_151(Config) -> markdown_test:testcase() when
    Config :: ct_suite:ct_config().
test_html_flow_case_151(_Config) ->
    ?assertMatch(
        {ok, <<"<blockquote>\n<p>a</p>\n</blockquote>\n<a>"/utf8>>},
        markdown:to_html_with_options(<<"> a\n<a>"/utf8>>, ?danger),
        "should not support lazyness (2)"
    ),
    ok.
