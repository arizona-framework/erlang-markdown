%%% % DO NOT EDIT: this file was generated by 'just codegen'
%%% % @generated <<SignedSource::*O*zOeWoEQle#+L!plEphiEmie@IsG>>
%%% % @format
%%%-----------------------------------------------------------------------------
%%% Copyright (c) Meta Platforms, Inc. and affiliates.
%%% Copyright (c) WhatsApp LLC
%%%
%%% This source code is licensed under the MIT license found in the
%%% LICENSE.md file in the root directory of this source tree.
%%%-----------------------------------------------------------------------------
-module(markdown_gfm_table_SUITE).
-moduledoc """

""".
-moduledoc #{author => ["Andrew Bennett <potatosaladx@meta.com>"]}.
-moduledoc #{created => "", modified => ""}.
-moduledoc #{copyright => "Meta Platforms, Inc. and affiliates."}.
-compile(warn_missing_spec_all).
-oncall("whatsapp_clr").

-include_lib("markdown/include/markdown_mdast.hrl").
-include_lib("markdown/include/markdown_util.hrl").
-include_lib("stdlib/include/assert.hrl").

-behaviour(ct_suite).

%% ct_suite callbacks
-export([
    all/0,
    groups/0,
    init_per_suite/1,
    end_per_suite/1,
    init_per_group/2,
    end_per_group/2
]).

%% Test Cases
-export([
    test_gfm_table_case_1/1,
    test_gfm_table_case_2/1,
    test_gfm_table_case_3/1,
    test_gfm_table_case_4/1,
    test_gfm_table_case_5/1,
    test_gfm_table_case_6/1,
    test_gfm_table_case_7/1,
    test_gfm_table_case_8/1,
    test_gfm_table_case_9/1,
    test_gfm_table_case_10/1,
    test_gfm_table_case_11/1,
    test_gfm_table_case_12/1,
    test_gfm_table_case_13/1,
    test_gfm_table_case_14/1,
    test_gfm_table_case_15/1,
    test_gfm_table_case_16/1,
    test_gfm_table_case_17/1,
    test_gfm_table_case_18/1,
    test_gfm_table_case_19/1,
    test_gfm_table_case_20/1,
    test_gfm_table_case_21/1,
    test_gfm_table_case_22/1,
    test_gfm_table_case_23/1,
    test_gfm_table_case_24/1,
    test_gfm_table_case_25/1,
    test_gfm_table_case_26/1,
    test_gfm_table_case_27/1,
    test_gfm_table_case_28/1,
    test_gfm_table_case_29/1,
    test_gfm_table_case_30/1,
    test_gfm_table_case_31/1,
    test_gfm_table_case_32/1,
    test_gfm_table_case_33/1,
    test_gfm_table_case_34/1,
    test_gfm_table_case_35/1,
    test_gfm_table_case_36/1,
    test_gfm_table_case_37/1,
    test_gfm_table_case_38/1,
    test_gfm_table_case_39/1,
    test_gfm_table_case_40/1,
    test_gfm_table_case_41/1,
    test_gfm_table_case_42/1,
    test_gfm_table_case_43/1,
    test_gfm_table_case_44/1,
    test_gfm_table_case_45/1,
    test_gfm_table_case_46/1,
    test_gfm_table_case_47/1,
    test_gfm_table_case_48/1,
    test_gfm_table_case_49/1,
    test_gfm_table_case_50/1,
    test_gfm_table_case_51/1,
    test_gfm_table_case_52/1,
    test_gfm_table_case_53/1,
    test_gfm_table_case_54/1,
    test_gfm_table_case_55/1,
    test_gfm_table_case_56/1,
    test_gfm_table_case_57/1,
    test_gfm_table_case_58/1,
    test_gfm_table_case_59/1,
    test_gfm_table_case_60/1,
    test_gfm_table_case_61/1,
    test_gfm_table_case_62/1,
    test_gfm_table_case_63/1,
    test_gfm_table_case_64/1,
    test_gfm_table_case_65/1,
    test_gfm_table_case_66/1
]).

%%%=============================================================================
%%% ct_suite callbacks
%%%=============================================================================

-spec all() -> markdown_test:all().
all() ->
    [
        {group, static}
    ].

-spec groups() -> markdown_test:groups().
groups() ->
    [
        {static, [parallel], [
            test_gfm_table_case_1,
            test_gfm_table_case_2,
            test_gfm_table_case_3,
            test_gfm_table_case_4,
            test_gfm_table_case_5,
            test_gfm_table_case_6,
            test_gfm_table_case_7,
            test_gfm_table_case_8,
            test_gfm_table_case_9,
            test_gfm_table_case_10,
            test_gfm_table_case_11,
            test_gfm_table_case_12,
            test_gfm_table_case_13,
            test_gfm_table_case_14,
            test_gfm_table_case_15,
            test_gfm_table_case_16,
            test_gfm_table_case_17,
            test_gfm_table_case_18,
            test_gfm_table_case_19,
            test_gfm_table_case_20,
            test_gfm_table_case_21,
            test_gfm_table_case_22,
            test_gfm_table_case_23,
            test_gfm_table_case_24,
            test_gfm_table_case_25,
            test_gfm_table_case_26,
            test_gfm_table_case_27,
            test_gfm_table_case_28,
            test_gfm_table_case_29,
            test_gfm_table_case_30,
            test_gfm_table_case_31,
            test_gfm_table_case_32,
            test_gfm_table_case_33,
            test_gfm_table_case_34,
            test_gfm_table_case_35,
            test_gfm_table_case_36,
            test_gfm_table_case_37,
            test_gfm_table_case_38,
            test_gfm_table_case_39,
            test_gfm_table_case_40,
            test_gfm_table_case_41,
            test_gfm_table_case_42,
            test_gfm_table_case_43,
            test_gfm_table_case_44,
            test_gfm_table_case_45,
            test_gfm_table_case_46,
            test_gfm_table_case_47,
            test_gfm_table_case_48,
            test_gfm_table_case_49,
            test_gfm_table_case_50,
            test_gfm_table_case_51,
            test_gfm_table_case_52,
            test_gfm_table_case_53,
            test_gfm_table_case_54,
            test_gfm_table_case_55,
            test_gfm_table_case_56,
            test_gfm_table_case_57,
            test_gfm_table_case_58,
            test_gfm_table_case_59,
            test_gfm_table_case_60,
            test_gfm_table_case_61,
            test_gfm_table_case_62,
            test_gfm_table_case_63,
            test_gfm_table_case_64,
            test_gfm_table_case_65,
            test_gfm_table_case_66
        ]}
    ].

-spec init_per_suite(Config :: ct_suite:ct_config()) -> markdown_test:init_per_suite().
init_per_suite(Config) ->
    Config.

-spec end_per_suite(Config :: ct_suite:ct_config()) -> markdown_test:end_per_suite().
end_per_suite(_Config) ->
    ok.

-spec init_per_group(GroupName :: ct_suite:ct_groupname(), Config :: ct_suite:ct_config()) ->
    markdown_test:init_per_group().
init_per_group(_Group, Config) ->
    Config.

-spec end_per_group(GroupName :: ct_suite:ct_groupname(), Config :: ct_suite:ct_config()) ->
    markdown_test:end_per_group().
end_per_group(_Group, _Config) ->
    ok.

%%%=============================================================================
%%% Test Cases
%%%=============================================================================

-spec test_gfm_table_case_1(Config) -> markdown_test:testcase() when
    Config :: ct_suite:ct_config().
test_gfm_table_case_1(_Config) ->
    ?assertMatch(
        {ok, <<"<p>| a |\n| - |\n| b |</p>"/utf8>>},
        markdown:to_html(<<"| a |\n| - |\n| b |"/utf8>>),
        "should ignore tables by default"
    ),
    ok.

-spec test_gfm_table_case_2(Config) -> markdown_test:testcase() when
    Config :: ct_suite:ct_config().
test_gfm_table_case_2(_Config) ->
    ?assertMatch(
        {ok,
            <<"<table>\n<thead>\n<tr>\n<th>a</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>b</td>\n</tr>\n</tbody>\n</table>"/utf8>>},
        markdown:to_html_with_options(<<"| a |\n| - |\n| b |"/utf8>>, markdown_options:gfm()),
        "should support tables"
    ),
    ok.

-spec test_gfm_table_case_3(Config) -> markdown_test:testcase() when
    Config :: ct_suite:ct_config().
test_gfm_table_case_3(_Config) ->
    ?assertMatch(
        {ok, <<"<p>| a |</p>"/utf8>>},
        markdown:to_html_with_options(<<"| a |"/utf8>>, markdown_options:gfm()),
        "should not support a table w/ the head row ending in an eof (1)"
    ),
    ok.

-spec test_gfm_table_case_4(Config) -> markdown_test:testcase() when
    Config :: ct_suite:ct_config().
test_gfm_table_case_4(_Config) ->
    ?assertMatch(
        {ok, <<"<p>| a</p>"/utf8>>},
        markdown:to_html_with_options(<<"| a"/utf8>>, markdown_options:gfm()),
        "should not support a table w/ the head row ending in an eof (2)"
    ),
    ok.

-spec test_gfm_table_case_5(Config) -> markdown_test:testcase() when
    Config :: ct_suite:ct_config().
test_gfm_table_case_5(_Config) ->
    ?assertMatch(
        {ok, <<"<p>a |</p>"/utf8>>},
        markdown:to_html_with_options(<<"a |"/utf8>>, markdown_options:gfm()),
        "should not support a table w/ the head row ending in an eof (3)"
    ),
    ok.

-spec test_gfm_table_case_6(Config) -> markdown_test:testcase() when
    Config :: ct_suite:ct_config().
test_gfm_table_case_6(_Config) ->
    ?assertMatch(
        {ok, <<"<table>\n<thead>\n<tr>\n<th>a</th>\n</tr>\n</thead>\n</table>"/utf8>>},
        markdown:to_html_with_options(<<"| a |\n| - |"/utf8>>, markdown_options:gfm()),
        "should support a table w/ a delimiter row ending in an eof (1)"
    ),
    ok.

-spec test_gfm_table_case_7(Config) -> markdown_test:testcase() when
    Config :: ct_suite:ct_config().
test_gfm_table_case_7(_Config) ->
    ?assertMatch(
        {ok, <<"<table>\n<thead>\n<tr>\n<th>a</th>\n</tr>\n</thead>\n</table>"/utf8>>},
        markdown:to_html_with_options(<<"| a\n| -"/utf8>>, markdown_options:gfm()),
        "should support a table w/ a delimiter row ending in an eof (2)"
    ),
    ok.

-spec test_gfm_table_case_8(Config) -> markdown_test:testcase() when
    Config :: ct_suite:ct_config().
test_gfm_table_case_8(_Config) ->
    ?assertMatch(
        {ok,
            <<"<table>\n<thead>\n<tr>\n<th>a</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>b</td>\n</tr>\n</tbody>\n</table>"/utf8>>},
        markdown:to_html_with_options(<<"| a |\n| - |\n| b |"/utf8>>, markdown_options:gfm()),
        "should support a table w/ a body row ending in an eof (1)"
    ),
    ok.

-spec test_gfm_table_case_9(Config) -> markdown_test:testcase() when
    Config :: ct_suite:ct_config().
test_gfm_table_case_9(_Config) ->
    ?assertMatch(
        {ok,
            <<"<table>\n<thead>\n<tr>\n<th>a</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>b</td>\n</tr>\n</tbody>\n</table>"/utf8>>},
        markdown:to_html_with_options(<<"| a\n| -\n| b"/utf8>>, markdown_options:gfm()),
        "should support a table w/ a body row ending in an eof (2)"
    ),
    ok.

-spec test_gfm_table_case_10(Config) -> markdown_test:testcase() when
    Config :: ct_suite:ct_config().
test_gfm_table_case_10(_Config) ->
    ?assertMatch(
        {ok,
            <<"<table>\n<thead>\n<tr>\n<th>a</th>\n<th>b</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>c</td>\n<td>d</td>\n</tr>\n</tbody>\n</table>"/utf8>>},
        markdown:to_html_with_options(<<"a|b\n-|-\nc|d"/utf8>>, markdown_options:gfm()),
        "should support a table w/ a body row ending in an eof (3)"
    ),
    ok.

-spec test_gfm_table_case_11(Config) -> markdown_test:testcase() when
    Config :: ct_suite:ct_config().
test_gfm_table_case_11(_Config) ->
    ?assertMatch(
        {ok,
            <<"<table>\n<thead>\n<tr>\n<th>a</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>b</td>\n</tr>\n</tbody>\n</table>"/utf8>>},
        markdown:to_html_with_options(<<"| a  \n| -\t\n| b |     "/utf8>>, markdown_options:gfm()),
        "should support rows w/ trailing whitespace (1)"
    ),
    ok.

-spec test_gfm_table_case_12(Config) -> markdown_test:testcase() when
    Config :: ct_suite:ct_config().
test_gfm_table_case_12(_Config) ->
    ?assertMatch(
        {ok, <<"<table>\n<thead>\n<tr>\n<th>a</th>\n</tr>\n</thead>\n</table>"/utf8>>},
        markdown:to_html_with_options(<<"| a | \n| - |"/utf8>>, markdown_options:gfm()),
        "should support rows w/ trailing whitespace (2)"
    ),
    ok.

-spec test_gfm_table_case_13(Config) -> markdown_test:testcase() when
    Config :: ct_suite:ct_config().
test_gfm_table_case_13(_Config) ->
    ?assertMatch(
        {ok, <<"<table>\n<thead>\n<tr>\n<th>a</th>\n</tr>\n</thead>\n</table>"/utf8>>},
        markdown:to_html_with_options(<<"| a |\n| - | "/utf8>>, markdown_options:gfm()),
        "should support rows w/ trailing whitespace (3)"
    ),
    ok.

-spec test_gfm_table_case_14(Config) -> markdown_test:testcase() when
    Config :: ct_suite:ct_config().
test_gfm_table_case_14(_Config) ->
    ?assertMatch(
        {ok,
            <<"<table>\n<thead>\n<tr>\n<th>a</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>b</td>\n</tr>\n</tbody>\n</table>"/utf8>>},
        markdown:to_html_with_options(<<"| a |\n| - |\n| b | "/utf8>>, markdown_options:gfm()),
        "should support rows w/ trailing whitespace (4)"
    ),
    ok.

-spec test_gfm_table_case_15(Config) -> markdown_test:testcase() when
    Config :: ct_suite:ct_config().
test_gfm_table_case_15(_Config) ->
    ?assertMatch(
        {ok, <<"<table>\n<thead>\n<tr>\n<th></th>\n<th>a</th>\n</tr>\n</thead>\n</table>"/utf8>>},
        markdown:to_html_with_options(<<"||a|\n|-|-|"/utf8>>, markdown_options:gfm()),
        "should support empty first header cells"
    ),
    ok.

-spec test_gfm_table_case_16(Config) -> markdown_test:testcase() when
    Config :: ct_suite:ct_config().
test_gfm_table_case_16(_Config) ->
    ?assertMatch(
        {ok, <<"<table>\n<thead>\n<tr>\n<th>a</th>\n<th></th>\n</tr>\n</thead>\n</table>"/utf8>>},
        markdown:to_html_with_options(<<"|a||\n|-|-|"/utf8>>, markdown_options:gfm()),
        "should support empty last header cells"
    ),
    ok.

-spec test_gfm_table_case_17(Config) -> markdown_test:testcase() when
    Config :: ct_suite:ct_config().
test_gfm_table_case_17(_Config) ->
    ?assertMatch(
        {ok, <<"<table>\n<thead>\n<tr>\n<th>a</th>\n<th></th>\n<th>b</th>\n</tr>\n</thead>\n</table>"/utf8>>},
        markdown:to_html_with_options(<<"a||b\n-|-|-"/utf8>>, markdown_options:gfm()),
        "should support empty header cells"
    ),
    ok.

-spec test_gfm_table_case_18(Config) -> markdown_test:testcase() when
    Config :: ct_suite:ct_config().
test_gfm_table_case_18(_Config) ->
    ?assertMatch(
        {ok,
            <<"<table>\n<thead>\n<tr>\n<th>a</th>\n<th>b</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td></td>\n<td>c</td>\n</tr>\n</tbody>\n</table>"/utf8>>},
        markdown:to_html_with_options(<<"|a|b|\n|-|-|\n||c|"/utf8>>, markdown_options:gfm()),
        "should support empty first body cells"
    ),
    ok.

-spec test_gfm_table_case_19(Config) -> markdown_test:testcase() when
    Config :: ct_suite:ct_config().
test_gfm_table_case_19(_Config) ->
    ?assertMatch(
        {ok,
            <<"<table>\n<thead>\n<tr>\n<th>a</th>\n<th>b</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>c</td>\n<td></td>\n</tr>\n</tbody>\n</table>"/utf8>>},
        markdown:to_html_with_options(<<"|a|b|\n|-|-|\n|c||"/utf8>>, markdown_options:gfm()),
        "should support empty last body cells"
    ),
    ok.

-spec test_gfm_table_case_20(Config) -> markdown_test:testcase() when
    Config :: ct_suite:ct_config().
test_gfm_table_case_20(_Config) ->
    ?assertMatch(
        {ok, <<"""
        <table>
        <thead>
        <tr>
        <th>a</th>
        <th>b</th>
        <th>c</th>
        </tr>
        </thead>
        <tbody>
        <tr>
        <td>d</td>
        <td></td>
        <td>e</td>
        </tr>
        </tbody>
        </table>
        """/utf8>>},
        markdown:to_html_with_options(<<"a|b|c\n-|-|-\nd||e"/utf8>>, markdown_options:gfm()),
        "should support empty body cells"
    ),
    ok.

-spec test_gfm_table_case_21(Config) -> markdown_test:testcase() when
    Config :: ct_suite:ct_config().
test_gfm_table_case_21(_Config) ->
    ?assertMatch(
        {ok, <<"""
        <table>
        <thead>
        <tr>
        <th>:</th>
        </tr>
        </thead>
        <tbody>
        <tr>
        <td>a</td>
        </tr>
        </tbody>
        </table>
        <table>
        <thead>
        <tr>
        <th>b</th>
        </tr>
        </thead>
        <tbody>
        <tr>
        <td>c</td>
        </tr>
        </tbody>
        </table>
        <p>|
        |-|
        |d|</p>
        <p>|
        |-|
        |e|</p>
        <table>
        <thead>
        <tr>
        <th>:</th>
        </tr>
        </thead>
        <tbody>
        <tr>
        <td>f</td>
        </tr>
        </tbody>
        </table>
        <table>
        <thead>
        <tr>
        <th></th>
        </tr>
        </thead>
        <tbody>
        <tr>
        <td>g</td>
        </tr>
        </tbody>
        </table>
        <table>
        <thead>
        <tr>
        <th></th>
        </tr>
        </thead>
        <tbody>
        <tr>
        <td>h</td>
        </tr>
        </tbody>
        </table>

        """/utf8>>},
        markdown:to_html_with_options(
            <<":\n|-|\n|a|\n\nb\n|-|\n|c|\n\n|\n|-|\n|d|\n\n|\n|-|\n|e|\n\n|:\n|-|\n|f|\n\n||\n|-|\n|g|\n\n| |\n|-|\n|h|\n"/utf8>>,
            markdown_options:gfm()
        ),
        "should need any character other than a single pipe in the header row"
    ),
    ok.

-spec test_gfm_table_case_22(Config) -> markdown_test:testcase() when
    Config :: ct_suite:ct_config().
test_gfm_table_case_22(_Config) ->
    ?assertMatch(
        {ok, <<"""
        <table>
        <thead>
        <tr>
        <th>a</th>
        </tr>
        </thead>
        </table>
        <p>b
        ||</p>
        <table>
        <thead>
        <tr>
        <th>c</th>
        </tr>
        </thead>
        </table>
        <p>d
        |:|</p>
        <p>e
        | |</p>
        <table>
        <thead>
        <tr>
        <th>f</th>
        </tr>
        </thead>
        </table>
        <table>
        <thead>
        <tr>
        <th>g</th>
        </tr>
        </thead>
        </table>

        """/utf8>>},
        markdown:to_html_with_options(
            <<"a\n|-\n\nb\n||\n\nc\n|-|\n\nd\n|:|\n\ne\n| |\n\nf\n| -|\n\ng\n|- |\n"/utf8>>, markdown_options:gfm()
        ),
        "should need a dash in the delimimter row"
    ),
    ok.

-spec test_gfm_table_case_23(Config) -> markdown_test:testcase() when
    Config :: ct_suite:ct_config().
test_gfm_table_case_23(_Config) ->
    ?assertMatch(
        {ok, <<"<p>|\n|</p>"/utf8>>},
        markdown:to_html_with_options(<<"|\n|"/utf8>>, markdown_options:gfm()),
        "should need something"
    ),
    ok.

-spec test_gfm_table_case_24(Config) -> markdown_test:testcase() when
    Config :: ct_suite:ct_config().
test_gfm_table_case_24(_Config) ->
    ?assertMatch(
        {ok, <<"<table>\n<thead>\n<tr>\n<th>a</th>\n</tr>\n</thead>\n</table>\n<ul>\n<li>b</li>\n</ul>"/utf8>>},
        markdown:to_html_with_options(<<"| a |\n| - |\n- b"/utf8>>, markdown_options:gfm()),
        "should support a list after a table"
    ),
    ok.

-spec test_gfm_table_case_25(Config) -> markdown_test:testcase() when
    Config :: ct_suite:ct_config().
test_gfm_table_case_25(_Config) ->
    ?assertMatch(
        {ok, <<"<blockquote>\n<p>| a |\n| - |</p>\n</blockquote>"/utf8>>},
        markdown:to_html_with_options(<<"> | a |\n| - |"/utf8>>, markdown_options:gfm()),
        "should not support a lazy delimiter row (1)"
    ),
    ok.

-spec test_gfm_table_case_26(Config) -> markdown_test:testcase() when
    Config :: ct_suite:ct_config().
test_gfm_table_case_26(_Config) ->
    ?assertMatch(
        {ok, <<"<blockquote>\n<p>a\n| b |\n| - |</p>\n</blockquote>"/utf8>>},
        markdown:to_html_with_options(<<"> a\n> | b |\n| - |"/utf8>>, markdown_options:gfm()),
        "should not support a lazy delimiter row (2)"
    ),
    ok.

-spec test_gfm_table_case_27(Config) -> markdown_test:testcase() when
    Config :: ct_suite:ct_config().
test_gfm_table_case_27(_Config) ->
    ?assertMatch(
        {ok, <<"<p>| a |</p>\n<blockquote>\n<p>| - |</p>\n</blockquote>"/utf8>>},
        markdown:to_html_with_options(<<"| a |\n> | - |"/utf8>>, markdown_options:gfm()),
        "should not support a piercing delimiter row"
    ),
    ok.

-spec test_gfm_table_case_28(Config) -> markdown_test:testcase() when
    Config :: ct_suite:ct_config().
test_gfm_table_case_28(_Config) ->
    ?assertMatch(
        {ok, <<"<blockquote>\n<p>a\n| b |\n|-</p>\n</blockquote>"/utf8>>},
        markdown:to_html_with_options(<<"> a\n> | b |\n|-"/utf8>>, markdown_options:gfm()),
        "should not support a lazy body row (2)"
    ),
    ok.

-spec test_gfm_table_case_29(Config) -> markdown_test:testcase() when
    Config :: ct_suite:ct_config().
test_gfm_table_case_29(_Config) ->
    ?assertMatch(
        {ok,
            <<"<blockquote>\n<table>\n<thead>\n<tr>\n<th>a</th>\n</tr>\n</thead>\n</table>\n</blockquote>\n<p>| b |</p>"/utf8>>},
        markdown:to_html_with_options(<<"> | a |\n> | - |\n| b |"/utf8>>, markdown_options:gfm()),
        "should not support a lazy body row (1)"
    ),
    ok.

-spec test_gfm_table_case_30(Config) -> markdown_test:testcase() when
    Config :: ct_suite:ct_config().
test_gfm_table_case_30(_Config) ->
    ?assertMatch(
        {ok,
            <<"<blockquote>\n<p>a</p>\n<table>\n<thead>\n<tr>\n<th>b</th>\n</tr>\n</thead>\n</table>\n</blockquote>\n<p>| c |</p>"/utf8>>},
        markdown:to_html_with_options(<<"> a\n> | b |\n> | - |\n| c |"/utf8>>, markdown_options:gfm()),
        "should not support a lazy body row (2)"
    ),
    ok.

-spec test_gfm_table_case_31(Config) -> markdown_test:testcase() when
    Config :: ct_suite:ct_config().
test_gfm_table_case_31(_Config) ->
    ?assertMatch(
        {ok, <<"""
        <blockquote>
        <table>
        <thead>
        <tr>
        <th>A</th>
        </tr>
        </thead>
        <tbody>
        <tr>
        <td>1</td>
        </tr>
        </tbody>
        </table>
        </blockquote>
        <p>| 2 |</p>
        """/utf8>>},
        markdown:to_html_with_options(<<"> | A |\n> | - |\n> | 1 |\n| 2 |"/utf8>>, markdown_options:gfm()),
        "should not support a lazy body row (3)"
    ),
    ok.

-spec test_gfm_table_case_32(Config) -> markdown_test:testcase() when
    Config :: ct_suite:ct_config().
test_gfm_table_case_32(_Config) ->
    ?assertMatch(
        {ok, <<"<table>\n<thead>\n<tr>\n<th>a</th>\n</tr>\n</thead>\n</table>"/utf8>>},
        markdown:to_html_with_options(<<"| a |\n   | - |"/utf8>>, markdown_options:gfm()),
        "should form a table if the delimiter row is indented w/ 3 spaces"
    ),
    ok.

-spec test_gfm_table_case_33(Config) -> markdown_test:testcase() when
    Config :: ct_suite:ct_config().
test_gfm_table_case_33(_Config) ->
    ?assertMatch(
        {ok, <<"<p>| a |\n| - |</p>"/utf8>>},
        markdown:to_html_with_options(<<"| a |\n    | - |"/utf8>>, markdown_options:gfm()),
        "should not form a table if the delimiter row is indented w/ 4 spaces"
    ),
    ok.

-spec test_gfm_table_case_34(Config) -> markdown_test:testcase() when
    Config :: ct_suite:ct_config().
test_gfm_table_case_34(_Config) ->
    ?assertMatch(
        {ok, <<"<table>\n<thead>\n<tr>\n<th>a</th>\n</tr>\n</thead>\n</table>"/utf8>>},
        markdown:to_html_with_options(
            <<"| a |\n    | - |"/utf8>>, markdown_options:gfm(#{parse => #{constructs => #{code_indented => false}}})
        ),
        "should form a table if the delimiter row is indented w/ 4 spaces and indented code is turned off"
    ),
    ok.

-spec test_gfm_table_case_35(Config) -> markdown_test:testcase() when
    Config :: ct_suite:ct_config().
test_gfm_table_case_35(_Config) ->
    ?assertMatch(
        {ok,
            <<"<table>\n<thead>\n<tr>\n<th>a</th>\n</tr>\n</thead>\n</table>\n<blockquote>\n<p>block quote?</p>\n</blockquote>"/utf8>>},
        markdown:to_html_with_options(<<"| a |\n| - |\n> block quote?"/utf8>>, markdown_options:gfm()),
        "should be interrupted by a block quote"
    ),
    ok.

-spec test_gfm_table_case_36(Config) -> markdown_test:testcase() when
    Config :: ct_suite:ct_config().
test_gfm_table_case_36(_Config) ->
    ?assertMatch(
        {ok, <<"<table>\n<thead>\n<tr>\n<th>a</th>\n</tr>\n</thead>\n</table>\n<blockquote>\n</blockquote>"/utf8>>},
        markdown:to_html_with_options(<<"| a |\n| - |\n>"/utf8>>, markdown_options:gfm()),
        "should be interrupted by a block quote (empty)"
    ),
    ok.

-spec test_gfm_table_case_37(Config) -> markdown_test:testcase() when
    Config :: ct_suite:ct_config().
test_gfm_table_case_37(_Config) ->
    ?assertMatch(
        {ok, <<"<table>\n<thead>\n<tr>\n<th>a</th>\n</tr>\n</thead>\n</table>\n<ul>\n<li>list?</li>\n</ul>"/utf8>>},
        markdown:to_html_with_options(<<"| a |\n| - |\n- list?"/utf8>>, markdown_options:gfm()),
        "should be interrupted by a list"
    ),
    ok.

-spec test_gfm_table_case_38(Config) -> markdown_test:testcase() when
    Config :: ct_suite:ct_config().
test_gfm_table_case_38(_Config) ->
    ?assertMatch(
        {ok, <<"<table>\n<thead>\n<tr>\n<th>a</th>\n</tr>\n</thead>\n</table>\n<ul>\n<li></li>\n</ul>"/utf8>>},
        markdown:to_html_with_options(<<"| a |\n| - |\n-"/utf8>>, markdown_options:gfm()),
        "should be interrupted by a list (empty)"
    ),
    ok.

-spec test_gfm_table_case_39(Config) -> markdown_test:testcase() when
    Config :: ct_suite:ct_config().
test_gfm_table_case_39(_Config) ->
    ?assertMatch(
        {ok, <<"<table>\n<thead>\n<tr>\n<th>a</th>\n</tr>\n</thead>\n</table>\n<!-- HTML? -->"/utf8>>},
        markdown:to_html_with_options(
            <<"| a |\n| - |\n<!-- HTML? -->"/utf8>>,
            markdown_options:gfm(#{compile => #{allow_dangerous_html => true, allow_dangerous_protocol => true}})
        ),
        "should be interrupted by HTML (flow)"
    ),
    ok.

-spec test_gfm_table_case_40(Config) -> markdown_test:testcase() when
    Config :: ct_suite:ct_config().
test_gfm_table_case_40(_Config) ->
    ?assertMatch(
        {ok, <<"<table>\n<thead>\n<tr>\n<th>a</th>\n</tr>\n</thead>\n</table>\n<pre><code>code?\n</code></pre>"/utf8>>},
        markdown:to_html_with_options(
            <<"| a |\n| - |\n\tcode?"/utf8>>,
            markdown_options:gfm(#{compile => #{allow_dangerous_html => true, allow_dangerous_protocol => true}})
        ),
        "should be interrupted by code (indented)"
    ),
    ok.

-spec test_gfm_table_case_41(Config) -> markdown_test:testcase() when
    Config :: ct_suite:ct_config().
test_gfm_table_case_41(_Config) ->
    ?assertMatch(
        {ok,
            <<"<table>\n<thead>\n<tr>\n<th>a</th>\n</tr>\n</thead>\n</table>\n<pre><code class=\"language-js\">code?\n</code></pre>\n"/utf8>>},
        markdown:to_html_with_options(
            <<"| a |\n| - |\n```js\ncode?"/utf8>>,
            markdown_options:gfm(#{compile => #{allow_dangerous_html => true, allow_dangerous_protocol => true}})
        ),
        "should be interrupted by code (fenced)"
    ),
    ok.

-spec test_gfm_table_case_42(Config) -> markdown_test:testcase() when
    Config :: ct_suite:ct_config().
test_gfm_table_case_42(_Config) ->
    ?assertMatch(
        {ok, <<"<table>\n<thead>\n<tr>\n<th>a</th>\n</tr>\n</thead>\n</table>\n<hr />"/utf8>>},
        markdown:to_html_with_options(
            <<"| a |\n| - |\n***"/utf8>>,
            markdown_options:gfm(#{compile => #{allow_dangerous_html => true, allow_dangerous_protocol => true}})
        ),
        "should be interrupted by a thematic break"
    ),
    ok.

-spec test_gfm_table_case_43(Config) -> markdown_test:testcase() when
    Config :: ct_suite:ct_config().
test_gfm_table_case_43(_Config) ->
    ?assertMatch(
        {ok, <<"<table>\n<thead>\n<tr>\n<th>a</th>\n</tr>\n</thead>\n</table>\n<h1>heading?</h1>"/utf8>>},
        markdown:to_html_with_options(<<"| a |\n| - |\n# heading?"/utf8>>, markdown_options:gfm()),
        "should be interrupted by a heading (ATX)"
    ),
    ok.

-spec test_gfm_table_case_44(Config) -> markdown_test:testcase() when
    Config :: ct_suite:ct_config().
test_gfm_table_case_44(_Config) ->
    ?assertMatch(
        {ok, <<"""
        <table>
        <thead>
        <tr>
        <th>a</th>
        </tr>
        </thead>
        <tbody>
        <tr>
        <td>heading</td>
        </tr>
        <tr>
        <td>=</td>
        </tr>
        </tbody>
        </table>
        """/utf8>>},
        markdown:to_html_with_options(<<"| a |\n| - |\nheading\n="/utf8>>, markdown_options:gfm()),
        "should *not* be interrupted by a heading (setext)"
    ),
    ok.

-spec test_gfm_table_case_45(Config) -> markdown_test:testcase() when
    Config :: ct_suite:ct_config().
test_gfm_table_case_45(_Config) ->
    ?assertMatch(
        {ok,
            <<"<table>\n<thead>\n<tr>\n<th>a</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>heading</td>\n</tr>\n</tbody>\n</table>\n<hr />"/utf8>>},
        markdown:to_html_with_options(<<"| a |\n| - |\nheading\n---"/utf8>>, markdown_options:gfm()),
        "should *not* be interrupted by a heading (setext), but interrupt if the underline is also a thematic break"
    ),
    ok.

-spec test_gfm_table_case_46(Config) -> markdown_test:testcase() when
    Config :: ct_suite:ct_config().
test_gfm_table_case_46(_Config) ->
    ?assertMatch(
        {ok, <<"""
        <table>
        <thead>
        <tr>
        <th>a</th>
        </tr>
        </thead>
        <tbody>
        <tr>
        <td>heading</td>
        </tr>
        </tbody>
        </table>
        <ul>
        <li></li>
        </ul>
        """/utf8>>},
        markdown:to_html_with_options(<<"| a |\n| - |\nheading\n-"/utf8>>, markdown_options:gfm()),
        "should *not* be interrupted by a heading (setext), but interrupt if the underline is also an empty list item bullet"
    ),
    ok.

-spec test_gfm_table_case_47(Config) -> markdown_test:testcase() when
    Config :: ct_suite:ct_config().
test_gfm_table_case_47(_Config) ->
    ?assertMatch(
        {ok, <<"<p>a</p>\n<table>\n<thead>\n<tr>\n<th align=\"right\">b</th>\n</tr>\n</thead>\n</table>"/utf8>>},
        markdown:to_html_with_options(<<"a\nb\n-:"/utf8>>, markdown_options:gfm()),
        "should support a single head row"
    ),
    ok.

-spec test_gfm_table_case_48(Config) -> markdown_test:testcase() when
    Config :: ct_suite:ct_config().
test_gfm_table_case_48(_Config) ->
    ?assertMatch(
        {ok, <<"<blockquote>\n<table>\n<thead>\n<tr>\n<th>a</th>\n</tr>\n</thead>\n</table>\n</blockquote>"/utf8>>},
        markdown:to_html_with_options(<<"> | a |\n> | - |"/utf8>>, markdown_options:gfm()),
        "should support a table in a container"
    ),
    ok.

-spec test_gfm_table_case_49(Config) -> markdown_test:testcase() when
    Config :: ct_suite:ct_config().
test_gfm_table_case_49(_Config) ->
    ?assertMatch(
        {ok, <<"<blockquote>\n<p>| a |\n| - |</p>\n</blockquote>"/utf8>>},
        markdown:to_html_with_options(<<"> | a |\n| - |"/utf8>>, markdown_options:gfm()),
        "should not support a lazy delimiter row if the head row is in a container"
    ),
    ok.

-spec test_gfm_table_case_50(Config) -> markdown_test:testcase() when
    Config :: ct_suite:ct_config().
test_gfm_table_case_50(_Config) ->
    ?assertMatch(
        {ok, <<"<p>| a |</p>\n<blockquote>\n<p>| - |</p>\n</blockquote>"/utf8>>},
        markdown:to_html_with_options(<<"| a |\n> | - |"/utf8>>, markdown_options:gfm()),
        "should not support a “piercing” container for the delimiter row, if the head row was not in that container"
    ),
    ok.

-spec test_gfm_table_case_51(Config) -> markdown_test:testcase() when
    Config :: ct_suite:ct_config().
test_gfm_table_case_51(_Config) ->
    ?assertMatch(
        {ok,
            <<"<blockquote>\n<table>\n<thead>\n<tr>\n<th>a</th>\n</tr>\n</thead>\n</table>\n</blockquote>\n<p>| c |</p>"/utf8>>},
        markdown:to_html_with_options(<<"> | a |\n> | - |\n| c |"/utf8>>, markdown_options:gfm()),
        "should not support a lazy body row if the head row and delimiter row are in a container"
    ),
    ok.

-spec test_gfm_table_case_52(Config) -> markdown_test:testcase() when
    Config :: ct_suite:ct_config().
test_gfm_table_case_52(_Config) ->
    ?assertMatch(
        {ok, <<"<blockquote>\n<p>| a |\n| - |\n| c |</p>\n</blockquote>"/utf8>>},
        markdown:to_html_with_options(<<"> | a |\n| - |\n> | c |"/utf8>>, markdown_options:gfm()),
        "should not support a lazy delimiter row if the head row and a further body row are in a container"
    ),
    ok.

-spec test_gfm_table_case_53(Config) -> markdown_test:testcase() when
    Config :: ct_suite:ct_config().
test_gfm_table_case_53(_Config) ->
    ?assertMatch(
        {ok, <<"""
        <p>[</p>
        <table>
        <thead>
        <tr>
        <th align="left">a</th>
        </tr>
        </thead>
        <tbody>
        <tr>
        <td align="left">]: b</td>
        </tr>
        </tbody>
        </table>
        """/utf8>>},
        markdown:to_html_with_options(<<"[\na\n:-\n]: b"/utf8>>, markdown_options:gfm()),
        "should prefer GFM tables over definitions"
    ),
    ok.

-spec test_gfm_table_case_54(Config) -> markdown_test:testcase() when
    Config :: ct_suite:ct_config().
test_gfm_table_case_54(_Config) ->
    ?assertMatch(
        {ok,
            <<"<table>\n<thead>\n<tr>\n<th>a</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>b</td>\n</tr>\n</tbody>\n</table>"/utf8>>},
        markdown:to_html_with_options(
            <<"    | a |\n\t| - |\n    | b |"/utf8>>,
            markdown_options:gfm(#{parse => #{constructs => #{code_indented => false}}})
        ),
        "should support indented rows if code (indented) is off"
    ),
    ok.

-spec test_gfm_table_case_55(Config) -> markdown_test:testcase() when
    Config :: ct_suite:ct_config().
test_gfm_table_case_55(_Config) ->
    ?assertMatch(
        {ok, <<"""
        <h1>Align</h1>
        <h2>An empty initial cell</h2>
        <table>
        <thead>
        <tr>
        <th></th>
        <th align="center">a</th>
        <th align="left">c</th>
        </tr>
        </thead>
        <tbody>
        <tr>
        <td>a</td>
        <td align="center">b</td>
        <td align="left">c</td>
        </tr>
        <tr>
        <td>a</td>
        <td align="center">b</td>
        <td align="left">c</td>
        </tr>
        </tbody>
        </table>
        <h2>Missing alignment characters</h2>
        <p>| a | b | c |
        |   |---|---|
        | d | e | f |</p>
        <hr />
        <p>| a | b | c |
        |---|---|   |
        | d | e | f |</p>
        <h2>Incorrect characters</h2>
        <p>| a | b | c |
        |---|-*-|---|
        | d | e | f |</p>
        <h2>Two alignments</h2>
        <p>|a|
        |::|</p>
        <table>
        <thead>
        <tr>
        <th align="center">a</th>
        </tr>
        </thead>
        </table>
        <h2>Two at the start or end</h2>
        <p>|a|
        |::-|</p>
        <p>|a|
        |-::|</p>
        <h2>In the middle</h2>
        <p>|a|
        |-:-|</p>
        <h2>A space in the middle</h2>
        <p>|a|
        |- -|</p>
        <h2>No pipe</h2>
        <table>
        <thead>
        <tr>
        <th align="center">a</th>
        </tr>
        </thead>
        </table>
        <table>
        <thead>
        <tr>
        <th align="left">a</th>
        </tr>
        </thead>
        </table>
        <table>
        <thead>
        <tr>
        <th align="right">a</th>
        </tr>
        </thead>
        </table>
        <h2>A single colon</h2>
        <p>|a|
        |:|</p>
        <p>a
        :</p>
        <h2>Alignment on empty cells</h2>
        <table>
        <thead>
        <tr>
        <th>a</th>
        <th>b</th>
        <th align="left">c</th>
        <th align="right">d</th>
        <th align="center">e</th>
        </tr>
        </thead>
        <tbody>
        <tr>
        <td>f</td>
        <td></td>
        <td align="left"></td>
        <td align="right"></td>
        <td align="center"></td>
        </tr>
        </tbody>
        </table>

        """/utf8>>},
        markdown:to_html_with_options(<<"""
        # Align

        ## An empty initial cell

        | | a|c|
        |--|:----:|:---|
        |a|b|c|
        |a|b|c|

        ## Missing alignment characters

        | a | b | c |
        |   |---|---|
        | d | e | f |

        * * *

        | a | b | c |
        |---|---|   |
        | d | e | f |

        ## Incorrect characters

        | a | b | c |
        |---|-*-|---|
        | d | e | f |

        ## Two alignments

        |a|
        |::|

        |a|
        |:-:|

        ## Two at the start or end

        |a|
        |::-|

        |a|
        |-::|

        ## In the middle

        |a|
        |-:-|

        ## A space in the middle

        |a|
        |- -|

        ## No pipe

        a
        :-:

        a
        :-

        a
        -:

        ## A single colon

        |a|
        |:|

        a
        :

        ## Alignment on empty cells

        | a | b | c | d | e |
        | - | - | :- | -: | :-: |
        | f |

        """/utf8>>, markdown_options:gfm()),
        "should match alignment like GitHub"
    ),
    ok.

-spec test_gfm_table_case_56(Config) -> markdown_test:testcase() when
    Config :: ct_suite:ct_config().
test_gfm_table_case_56(_Config) ->
    ?assertMatch(
        {ok, <<"""
        <h1>Tables</h1>
        <table>
        <thead>
        <tr>
        <th>a</th>
        <th>b</th>
        <th>c</th>
        </tr>
        </thead>
        <tbody>
        <tr>
        <td>d</td>
        <td>e</td>
        <td>f</td>
        </tr>
        </tbody>
        </table>
        <h2>No body</h2>
        <table>
        <thead>
        <tr>
        <th>a</th>
        <th>b</th>
        <th>c</th>
        </tr>
        </thead>
        </table>
        <h2>One column</h2>
        <table>
        <thead>
        <tr>
        <th>a</th>
        </tr>
        </thead>
        <tbody>
        <tr>
        <td>b</td>
        </tr>
        </tbody>
        </table>

        """/utf8>>},
        markdown:to_html_with_options(<<"""
        # Tables

        | a | b | c |
        | - | - | - |
        | d | e | f |

        ## No body

        | a | b | c |
        | - | - | - |

        ## One column

        | a |
        | - |
        | b |

        """/utf8>>, markdown_options:gfm()),
        "should match basic like GitHub"
    ),
    ok.

-spec test_gfm_table_case_57(Config) -> markdown_test:testcase() when
    Config :: ct_suite:ct_config().
test_gfm_table_case_57(_Config) ->
    ?assertMatch(
        {ok, <<"""
        <h1>Tables in things</h1>
        <h2>In lists</h2>
        <ul>
        <li>
        <p>Unordered:</p>
        <table>
        <thead>
        <tr>
        <th>A</th>
        <th>B</th>
        </tr>
        </thead>
        <tbody>
        <tr>
        <td>1</td>
        <td>2</td>
        </tr>
        </tbody>
        </table>
        </li>
        </ul>
        <ol>
        <li>
        <p>Ordered:</p>
        <table>
        <thead>
        <tr>
        <th>A</th>
        <th>B</th>
        </tr>
        </thead>
        <tbody>
        <tr>
        <td>1</td>
        <td>2</td>
        </tr>
        </tbody>
        </table>
        </li>
        </ol>
        <ul>
        <li>Lazy?
        <table>
        <thead>
        <tr>
        <th>A</th>
        <th>B</th>
        </tr>
        </thead>
        </table>
        </li>
        </ul>
        <p>| 1 | 2 |
        | 3 | 4 |
        | 5 | 6 |
        | 7 | 8 |</p>
        <h2>In block quotes</h2>
        <blockquote>
        <p>W/ space:</p>
        <table>
        <thead>
        <tr>
        <th>A</th>
        <th>B</th>
        </tr>
        </thead>
        <tbody>
        <tr>
        <td>1</td>
        <td>2</td>
        </tr>
        </tbody>
        </table>
        </blockquote>
        <blockquote>
        <p>W/o space:</p>
        <table>
        <thead>
        <tr>
        <th>A</th>
        <th>B</th>
        </tr>
        </thead>
        <tbody>
        <tr>
        <td>1</td>
        <td>2</td>
        </tr>
        </tbody>
        </table>
        </blockquote>
        <blockquote>
        <p>Lazy?</p>
        <table>
        <thead>
        <tr>
        <th>A</th>
        <th>B</th>
        </tr>
        </thead>
        <tbody>
        <tr>
        <td>1</td>
        <td>2</td>
        </tr>
        <tr>
        <td>3</td>
        <td>4</td>
        </tr>
        </tbody>
        </table>
        </blockquote>
        <p>| 5 | 6 |</p>
        <h3>List interrupting delimiters</h3>
        <p>a |</p>
        <ul>
        <li>|</li>
        </ul>
        <table>
        <thead>
        <tr>
        <th>a</th>
        </tr>
        </thead>
        </table>
        <table>
        <thead>
        <tr>
        <th>a</th>
        </tr>
        </thead>
        </table>

        """/utf8>>},
        markdown:to_html_with_options(<<"""
        # Tables in things

        ## In lists

        *   Unordered:

            | A | B |
            | - | - |
            | 1 | 2 |

        1.  Ordered:

            | A | B |
            | - | - |
            | 1 | 2 |

        *   Lazy?
            | A | B |
            | - | - |
           | 1 | 2 |
          | 3 | 4 |
         | 5 | 6 |
        | 7 | 8 |

        ## In block quotes

        > W/ space:
        > | A | B |
        > | - | - |
        > | 1 | 2 |

        >W/o space:
        >| A | B |
        >| - | - |
        >| 1 | 2 |

        > Lazy?
        > | A | B |
        > | - | - |
        > | 1 | 2 |
        >| 3 | 4 |
        | 5 | 6 |

        ### List interrupting delimiters

        a |
        - |

        a
        -|

        a
        |-

        """/utf8>>, markdown_options:gfm()),
        "should match containers like GitHub"
    ),
    ok.

-spec test_gfm_table_case_58(Config) -> markdown_test:testcase() when
    Config :: ct_suite:ct_config().
test_gfm_table_case_58(_Config) ->
    ?assertMatch(
        {ok,
            <<"<table>\n<thead>\n<tr>\n<th>a</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>-</td>\n</tr>\n<tr>\n<td>1</td>\n</tr>\n</tbody>\n</table>\n"/utf8>>},
        markdown:to_html_with_options(<<"| a |\n| - |\n| - |\n| 1 |\n"/utf8>>, markdown_options:gfm()),
        "should match a double delimiter row like GitHub"
    ),
    ok.

-spec test_gfm_table_case_59(Config) -> markdown_test:testcase() when
    Config :: ct_suite:ct_config().
test_gfm_table_case_59(_Config) ->
    ?assertMatch(
        {ok, <<"""
        <h1>Examples from GFM</h1>
        <h2>A</h2>
        <table>
        <thead>
        <tr>
        <th>foo</th>
        <th>bar</th>
        </tr>
        </thead>
        <tbody>
        <tr>
        <td>baz</td>
        <td>bim</td>
        </tr>
        </tbody>
        </table>
        <h2>B</h2>
        <table>
        <thead>
        <tr>
        <th align="center">abc</th>
        <th align="right">defghi</th>
        </tr>
        </thead>
        <tbody>
        <tr>
        <td align="center">bar</td>
        <td align="right">baz</td>
        </tr>
        </tbody>
        </table>
        <h2>C</h2>
        <table>
        <thead>
        <tr>
        <th>f|oo</th>
        </tr>
        </thead>
        <tbody>
        <tr>
        <td>b <code>|</code> az</td>
        </tr>
        <tr>
        <td>b <strong>|</strong> im</td>
        </tr>
        </tbody>
        </table>
        <h2>D</h2>
        <table>
        <thead>
        <tr>
        <th>abc</th>
        <th>def</th>
        </tr>
        </thead>
        <tbody>
        <tr>
        <td>bar</td>
        <td>baz</td>
        </tr>
        </tbody>
        </table>
        <blockquote>
        <p>bar</p>
        </blockquote>
        <h2>E</h2>
        <table>
        <thead>
        <tr>
        <th>abc</th>
        <th>def</th>
        </tr>
        </thead>
        <tbody>
        <tr>
        <td>bar</td>
        <td>baz</td>
        </tr>
        <tr>
        <td>bar</td>
        <td></td>
        </tr>
        </tbody>
        </table>
        <p>bar</p>
        <h2>F</h2>
        <p>| abc | def |
        | --- |
        | bar |</p>
        <h2>G</h2>
        <table>
        <thead>
        <tr>
        <th>abc</th>
        <th>def</th>
        </tr>
        </thead>
        <tbody>
        <tr>
        <td>bar</td>
        <td></td>
        </tr>
        <tr>
        <td>bar</td>
        <td>baz</td>
        </tr>
        </tbody>
        </table>
        <h2>H</h2>
        <table>
        <thead>
        <tr>
        <th>abc</th>
        <th>def</th>
        </tr>
        </thead>
        </table>

        """/utf8>>},
        markdown:to_html_with_options(<<"""
        # Examples from GFM

        ## A

        | foo | bar |
        | --- | --- |
        | baz | bim |

        ## B

        | abc | defghi |
        :-: | -----------:
        bar | baz

        ## C

        | f\|oo  |
        | ------ |
        | b `\|` az |
        | b **\|** im |

        ## D

        | abc | def |
        | --- | --- |
        | bar | baz |
        > bar

        ## E

        | abc | def |
        | --- | --- |
        | bar | baz |
        bar

        bar

        ## F

        | abc | def |
        | --- |
        | bar |

        ## G

        | abc | def |
        | --- | --- |
        | bar |
        | bar | baz | boo |

        ## H

        | abc | def |
        | --- | --- |

        """/utf8>>, markdown_options:gfm()),
        "should match examples from the GFM spec like GitHub"
    ),
    ok.

-spec test_gfm_table_case_60(Config) -> markdown_test:testcase() when
    Config :: ct_suite:ct_config().
test_gfm_table_case_60(_Config) ->
    ?assertMatch(
        {ok, <<"""
        <h1>Grave accents</h1>
        <h2>Grave accent in cell</h2>
        <table>
        <thead>
        <tr>
        <th>A</th>
        <th>B</th>
        </tr>
        </thead>
        <tbody>
        <tr>
        <td><kbd>`</kbd></td>
        <td>C</td>
        </tr>
        </tbody>
        </table>
        <h2>Escaped grave accent in “inline code” in cell</h2>
        <table>
        <thead>
        <tr>
        <th>A</th>
        </tr>
        </thead>
        <tbody>
        <tr>
        <td><code>\</code></td>
        </tr>
        </tbody>
        </table>
        <h2>“Empty” inline code</h2>
        <table>
        <thead>
        <tr>
        <th>1</th>
        <th>2</th>
        <th>3</th>
        </tr>
        </thead>
        <tbody>
        <tr>
        <td>a</td>
        <td>``</td>
        <td></td>
        </tr>
        <tr>
        <td>b</td>
        <td>``</td>
        <td>``</td>
        </tr>
        <tr>
        <td>c</td>
        <td>`</td>
        <td>`</td>
        </tr>
        <tr>
        <td>d</td>
        <td>`</td>
        <td>`</td>
        </tr>
        <tr>
        <td>e</td>
        <td><code>|</code></td>
        <td></td>
        </tr>
        <tr>
        <td>f</td>
        <td>|</td>
        <td></td>
        </tr>
        </tbody>
        </table>
        <h2>Escaped pipes in code in cells</h2>
        <table>
        <thead>
        <tr>
        <th><code>|\\</code></th>
        </tr>
        </thead>
        <tbody>
        <tr>
        <td><code>|\\</code></td>
        </tr>
        </tbody>
        </table>
        <p><code>\|\\</code></p>

        """/utf8>>},
        markdown:to_html_with_options(
            <<"""
            # Grave accents

            ## Grave accent in cell

            | A            | B |
            |--------------|---|
            | <kbd>`</kbd> | C |

            ## Escaped grave accent in “inline code” in cell

            | A   |
            |-----|
            | `\` |

            ## “Empty” inline code

            | 1 | 2    | 3  |
            |---|------|----|
            | a |   `` |    |
            | b |   `` | `` |
            | c |    ` | `  |
            | d |     `|`   |
            | e | `\|` |    |
            | f |   \| |    |

            ## Escaped pipes in code in cells

            | `\|\\` |
            | --- |
            | `\|\\` |

            `\|\\`

            """/utf8>>,
            markdown_options:gfm(#{compile => #{allow_dangerous_html => true, allow_dangerous_protocol => true}})
        ),
        "should match grave accent like GitHub"
    ),
    ok.

-spec test_gfm_table_case_61(Config) -> markdown_test:testcase() when
    Config :: ct_suite:ct_config().
test_gfm_table_case_61(_Config) ->
    ?assertMatch(
        {ok, <<"""
        <h1>Code</h1>
        <h2>Indented delimiter row</h2>
        <table>
        <thead>
        <tr>
        <th>a</th>
        </tr>
        </thead>
        </table>
        <p>a
        |-</p>
        <h2>Indented body</h2>
        <table>
        <thead>
        <tr>
        <th>a</th>
        </tr>
        </thead>
        <tbody>
        <tr>
        <td>C</td>
        </tr>
        <tr>
        <td>D</td>
        </tr>
        </tbody>
        </table>
        <pre><code>| E |
        </code></pre>

        """/utf8>>},
        markdown:to_html_with_options(
            <<"# Code\n\n## Indented delimiter row\n\na\n   |-\n\na\n    |-\n\n## Indented body\n\n| a |\n | - |\n  | C |\n   | D |\n    | E |\n"/utf8>>,
            markdown_options:gfm()
        ),
        "should match indent like GitHub"
    ),
    ok.

-spec test_gfm_table_case_62(Config) -> markdown_test:testcase() when
    Config :: ct_suite:ct_config().
test_gfm_table_case_62(_Config) ->
    ?assertMatch(
        {ok, <<"""
        <h2>Blank line</h2>
        <table>
        <thead>
        <tr>
        <th align="left">a</th>
        </tr>
        </thead>
        <tbody>
        <tr>
        <td align="left">b</td>
        </tr>
        </tbody>
        </table>
        <p>c</p>
        <h2>Block quote</h2>
        <table>
        <thead>
        <tr>
        <th align="left">a</th>
        </tr>
        </thead>
        <tbody>
        <tr>
        <td align="left">b</td>
        </tr>
        </tbody>
        </table>
        <blockquote>
        <p>c</p>
        </blockquote>
        <h2>Code (fenced)</h2>
        <table>
        <thead>
        <tr>
        <th align="left">a</th>
        </tr>
        </thead>
        <tbody>
        <tr>
        <td align="left">b</td>
        </tr>
        </tbody>
        </table>
        <pre><code>c
        </code></pre>
        <h2>Code (indented)</h2>
        <table>
        <thead>
        <tr>
        <th align="left">a</th>
        </tr>
        </thead>
        <tbody>
        <tr>
        <td align="left">b</td>
        </tr>
        </tbody>
        </table>
        <pre><code>c
        </code></pre>
        <h2>Definition</h2>
        <table>
        <thead>
        <tr>
        <th align="left">a</th>
        </tr>
        </thead>
        <tbody>
        <tr>
        <td align="left">b</td>
        </tr>
        <tr>
        <td align="left">[c]: d</td>
        </tr>
        </tbody>
        </table>
        <h2>Heading (atx)</h2>
        <table>
        <thead>
        <tr>
        <th align="left">a</th>
        </tr>
        </thead>
        <tbody>
        <tr>
        <td align="left">b</td>
        </tr>
        </tbody>
        </table>
        <h1>c</h1>
        <h2>Heading (setext) (rank 1)</h2>
        <table>
        <thead>
        <tr>
        <th align="left">a</th>
        </tr>
        </thead>
        <tbody>
        <tr>
        <td align="left">b</td>
        </tr>
        <tr>
        <td align="left">==</td>
        </tr>
        <tr>
        <td align="left">c</td>
        </tr>
        </tbody>
        </table>
        <h2>Heading (setext) (rank 2)</h2>
        <table>
        <thead>
        <tr>
        <th align="left">a</th>
        </tr>
        </thead>
        <tbody>
        <tr>
        <td align="left">b</td>
        </tr>
        <tr>
        <td align="left">--</td>
        </tr>
        <tr>
        <td align="left">c</td>
        </tr>
        </tbody>
        </table>
        <h2>HTML (flow, kind 1: raw)</h2>
        <table>
        <thead>
        <tr>
        <th align="left">a</th>
        </tr>
        </thead>
        <tbody>
        <tr>
        <td align="left">b</td>
        </tr>
        </tbody>
        </table>
        <pre>
          a
        </pre>
        <h2>HTML (flow, kind 2: comment)</h2>
        <table>
        <thead>
        <tr>
        <th align="left">a</th>
        </tr>
        </thead>
        <tbody>
        <tr>
        <td align="left">b</td>
        </tr>
        </tbody>
        </table>
        <!-- c -->
        <h2>HTML (flow, kind 3: instruction)</h2>
        <table>
        <thead>
        <tr>
        <th align="left">a</th>
        </tr>
        </thead>
        <tbody>
        <tr>
        <td align="left">b</td>
        </tr>
        </tbody>
        </table>
        <? c ?>
        <h2>HTML (flow, kind 4: declaration)</h2>
        <table>
        <thead>
        <tr>
        <th align="left">a</th>
        </tr>
        </thead>
        <tbody>
        <tr>
        <td align="left">b</td>
        </tr>
        </tbody>
        </table>
        <!C>
        <h2>HTML (flow, kind 5: cdata)</h2>
        <table>
        <thead>
        <tr>
        <th align="left">a</th>
        </tr>
        </thead>
        <tbody>
        <tr>
        <td align="left">b</td>
        </tr>
        </tbody>
        </table>
        <![CDATA[c]]>
        <h2>HTML (flow, kind 6: basic)</h2>
        <table>
        <thead>
        <tr>
        <th align="left">a</th>
        </tr>
        </thead>
        <tbody>
        <tr>
        <td align="left">b</td>
        </tr>
        </tbody>
        </table>
        <div>
        <h2>HTML (flow, kind 7: complete)</h2>
        <table>
        <thead>
        <tr>
        <th align="left">a</th>
        </tr>
        </thead>
        <tbody>
        <tr>
        <td align="left">b</td>
        </tr>
        </tbody>
        </table>
        <x>
        <h2>List (ordered, 1)</h2>
        <table>
        <thead>
        <tr>
        <th align="left">a</th>
        </tr>
        </thead>
        <tbody>
        <tr>
        <td align="left">b</td>
        </tr>
        </tbody>
        </table>
        <ol>
        <li>c</li>
        </ol>
        <h2>List (ordered, other)</h2>
        <table>
        <thead>
        <tr>
        <th align="left">a</th>
        </tr>
        </thead>
        <tbody>
        <tr>
        <td align="left">b</td>
        </tr>
        </tbody>
        </table>
        <ol start="2">
        <li>c</li>
        </ol>
        <h2>List (unordered)</h2>
        <table>
        <thead>
        <tr>
        <th align="left">a</th>
        </tr>
        </thead>
        <tbody>
        <tr>
        <td align="left">b</td>
        </tr>
        </tbody>
        </table>
        <ul>
        <li>c</li>
        </ul>
        <h2>List (unordered, blank)</h2>
        <table>
        <thead>
        <tr>
        <th align="left">a</th>
        </tr>
        </thead>
        <tbody>
        <tr>
        <td align="left">b</td>
        </tr>
        </tbody>
        </table>
        <ul>
        <li></li>
        </ul>
        <p>c</p>
        <h2>List (unordered, blank start)</h2>
        <table>
        <thead>
        <tr>
        <th align="left">a</th>
        </tr>
        </thead>
        <tbody>
        <tr>
        <td align="left">b</td>
        </tr>
        </tbody>
        </table>
        <ul>
        <li>c</li>
        </ul>
        <h2>Thematic break</h2>
        <table>
        <thead>
        <tr>
        <th align="left">a</th>
        </tr>
        </thead>
        <tbody>
        <tr>
        <td align="left">b</td>
        </tr>
        </tbody>
        </table>
        <hr />

        """/utf8>>},
        markdown:to_html_with_options(
            <<"""
            ## Blank line

            a
            :-
            b

            c

            ## Block quote

            a
            :-
            b
            > c

            ## Code (fenced)

            a
            :-
            b
            ```
            c
            ```

            ## Code (indented)

            a
            :-
            b
                c

            ## Definition

            a
            :-
            b
            [c]: d

            ## Heading (atx)

            a
            :-
            b
            # c


            ## Heading (setext) (rank 1)

            a
            :-
            b
            ==
            c

            ## Heading (setext) (rank 2)

            a
            :-
            b
            --
            c

            ## HTML (flow, kind 1: raw)

            a
            :-
            b
            <pre>
              a
            </pre>

            ## HTML (flow, kind 2: comment)

            a
            :-
            b
            <!-- c -->

            ## HTML (flow, kind 3: instruction)

            a
            :-
            b
            <? c ?>

            ## HTML (flow, kind 4: declaration)

            a
            :-
            b
            <!C>

            ## HTML (flow, kind 5: cdata)

            a
            :-
            b
            <![CDATA[c]]>

            ## HTML (flow, kind 6: basic)

            a
            :-
            b
            <div>

            ## HTML (flow, kind 7: complete)

            a
            :-
            b
            <x>

            ## List (ordered, 1)

            a
            :-
            b
            1. c

            ## List (ordered, other)

            a
            :-
            b
            2. c

            ## List (unordered)

            a
            :-
            b
            * c

            ## List (unordered, blank)

            a
            :-
            b
            *
            c

            ## List (unordered, blank start)

            a
            :-
            b
            *
              c

            ## Thematic break

            a
            :-
            b
            ***

            """/utf8>>,
            markdown_options:gfm(#{compile => #{allow_dangerous_html => true, allow_dangerous_protocol => true}})
        ),
        "should match interrupt like GitHub"
    ),
    ok.

-spec test_gfm_table_case_63(Config) -> markdown_test:testcase() when
    Config :: ct_suite:ct_config().
test_gfm_table_case_63(_Config) ->
    ?assertMatch(
        {ok, <<"""
        <h1>Loose</h1>
        <h2>Loose</h2>
        <table>
        <thead>
        <tr>
        <th>Header 1</th>
        <th>Header 2</th>
        </tr>
        </thead>
        <tbody>
        <tr>
        <td>Cell 1</td>
        <td>Cell 2</td>
        </tr>
        <tr>
        <td>Cell 3</td>
        <td>Cell 4</td>
        </tr>
        </tbody>
        </table>
        <h2>One “column”, loose</h2>
        <h2>a</h2>
        <p>b</p>
        <h2>No pipe in first row</h2>
        <table>
        <thead>
        <tr>
        <th>a</th>
        </tr>
        </thead>
        </table>

        """/utf8>>},
        markdown:to_html_with_options(<<"""
        # Loose

        ## Loose

        Header 1 | Header 2
        -------- | --------
        Cell 1   | Cell 2
        Cell 3   | Cell 4

        ## One “column”, loose

        a
        -
        b

        ## No pipe in first row

        a
        | - |

        """/utf8>>, markdown_options:gfm()),
        "should match loose tables like GitHub"
    ),
    ok.

-spec test_gfm_table_case_64(Config) -> markdown_test:testcase() when
    Config :: ct_suite:ct_config().
test_gfm_table_case_64(_Config) ->
    ?assertMatch(
        {ok, <<"""
        <h1>Some more escapes</h1>
        <table>
        <thead>
        <tr>
        <th>Head</th>
        </tr>
        </thead>
        <tbody>
        <tr>
        <td>A</td>
        </tr>
        <tr>
        <td>B | Bravo</td>
        </tr>
        <tr>
        <td>C \</td>
        </tr>
        <tr>
        <td>D \| Delta</td>
        </tr>
        <tr>
        <td>E \\</td>
        </tr>
        </tbody>
        </table>
        <p>Note: GH has a bug where in case C and E, the escaped escape is treated as a
        normal escape: <a href="https://github.com/github/cmark-gfm/issues/277">https://github.com/github/cmark-gfm/issues/277</a>.</p>

        """/utf8>>},
        markdown:to_html_with_options(<<"""
        # Some more escapes

        | Head          |
        | ------------- |
        | A | Alpha     |
        | B \| Bravo    |
        | C \\| Charlie |
        | D \\\| Delta  |
        | E \\\\| Echo  |

        Note: GH has a bug where in case C and E, the escaped escape is treated as a
        normal escape: <https://github.com/github/cmark-gfm/issues/277>.

        """/utf8>>, markdown_options:gfm()),
        "should match loose escapes like GitHub"
    ),
    ok.

-spec test_gfm_table_case_65(Config) -> markdown_test:testcase() when
    Config :: ct_suite:ct_config().
test_gfm_table_case_65(_Config) ->
    ?assertEqual(
        {ok,
            markdown_mdast_node:root(#markdown_mdast_root{
                children = ?'vec!'([
                    markdown_mdast_node:table(#markdown_mdast_table{
                        align = ?'vec!'([
                            markdown_align_kind:none(),
                            markdown_align_kind:left(),
                            markdown_align_kind:right(),
                            markdown_align_kind:center()
                        ]),
                        children = ?'vec!'([
                            markdown_mdast_node:table_row(#markdown_mdast_table_row{
                                children = ?'vec!'([
                                    markdown_mdast_node:table_cell(#markdown_mdast_table_cell{
                                        children = ?'vec!'([
                                            markdown_mdast_node:text(#markdown_mdast_text{
                                                value = <<"none">>,
                                                position = {some, markdown_unist_position:new(1, 3, 2, 1, 7, 6)}
                                            })
                                        ]),
                                        position = {some, markdown_unist_position:new(1, 1, 0, 1, 8, 7)}
                                    }),
                                    markdown_mdast_node:table_cell(#markdown_mdast_table_cell{
                                        children = ?'vec!'([
                                            markdown_mdast_node:text(#markdown_mdast_text{
                                                value = <<"left">>,
                                                position = {some, markdown_unist_position:new(1, 10, 9, 1, 14, 13)}
                                            })
                                        ]),
                                        position = {some, markdown_unist_position:new(1, 8, 7, 1, 15, 14)}
                                    }),
                                    markdown_mdast_node:table_cell(#markdown_mdast_table_cell{
                                        children = ?'vec!'([
                                            markdown_mdast_node:text(#markdown_mdast_text{
                                                value = <<"right">>,
                                                position = {some, markdown_unist_position:new(1, 17, 16, 1, 22, 21)}
                                            })
                                        ]),
                                        position = {some, markdown_unist_position:new(1, 15, 14, 1, 23, 22)}
                                    }),
                                    markdown_mdast_node:table_cell(#markdown_mdast_table_cell{
                                        children = ?'vec!'([
                                            markdown_mdast_node:text(#markdown_mdast_text{
                                                value = <<"center">>,
                                                position = {some, markdown_unist_position:new(1, 25, 24, 1, 31, 30)}
                                            })
                                        ]),
                                        position = {some, markdown_unist_position:new(1, 23, 22, 1, 33, 32)}
                                    })
                                ]),
                                position = {some, markdown_unist_position:new(1, 1, 0, 1, 33, 32)}
                            }),
                            markdown_mdast_node:table_row(#markdown_mdast_table_row{
                                children = ?'vec!'([
                                    markdown_mdast_node:table_cell(#markdown_mdast_table_cell{
                                        children = ?'vec!'([
                                            markdown_mdast_node:text(#markdown_mdast_text{
                                                value = <<"a">>,
                                                position = {some, markdown_unist_position:new(3, 3, 57, 3, 4, 58)}
                                            })
                                        ]),
                                        position = {some, markdown_unist_position:new(3, 1, 55, 3, 6, 60)}
                                    })
                                ]),
                                position = {some, markdown_unist_position:new(3, 1, 55, 3, 6, 60)}
                            }),
                            markdown_mdast_node:table_row(#markdown_mdast_table_row{
                                children = ?'vec!'([
                                    markdown_mdast_node:table_cell(#markdown_mdast_table_cell{
                                        children = ?'vec!'([
                                            markdown_mdast_node:text(#markdown_mdast_text{
                                                value = <<"b">>,
                                                position = {some, markdown_unist_position:new(4, 3, 63, 4, 4, 64)}
                                            })
                                        ]),
                                        position = {some, markdown_unist_position:new(4, 1, 61, 4, 5, 65)}
                                    }),
                                    markdown_mdast_node:table_cell(#markdown_mdast_table_cell{
                                        children = ?'vec!'([
                                            markdown_mdast_node:text(#markdown_mdast_text{
                                                value = <<"c">>,
                                                position = {some, markdown_unist_position:new(4, 7, 67, 4, 8, 68)}
                                            })
                                        ]),
                                        position = {some, markdown_unist_position:new(4, 5, 65, 4, 9, 69)}
                                    }),
                                    markdown_mdast_node:table_cell(#markdown_mdast_table_cell{
                                        children = ?'vec!'([
                                            markdown_mdast_node:text(#markdown_mdast_text{
                                                value = <<"d">>,
                                                position = {some, markdown_unist_position:new(4, 11, 71, 4, 12, 72)}
                                            })
                                        ]),
                                        position = {some, markdown_unist_position:new(4, 9, 69, 4, 13, 73)}
                                    }),
                                    markdown_mdast_node:table_cell(#markdown_mdast_table_cell{
                                        children = ?'vec!'([
                                            markdown_mdast_node:text(#markdown_mdast_text{
                                                value = <<"e">>,
                                                position = {some, markdown_unist_position:new(4, 15, 75, 4, 16, 76)}
                                            })
                                        ]),
                                        position = {some, markdown_unist_position:new(4, 13, 73, 4, 17, 77)}
                                    }),
                                    markdown_mdast_node:table_cell(#markdown_mdast_table_cell{
                                        children = ?'vec!'([
                                            markdown_mdast_node:text(#markdown_mdast_text{
                                                value = <<"f">>,
                                                position = {some, markdown_unist_position:new(4, 19, 79, 4, 20, 80)}
                                            })
                                        ]),
                                        position = {some, markdown_unist_position:new(4, 17, 77, 4, 22, 82)}
                                    })
                                ]),
                                position = {some, markdown_unist_position:new(4, 1, 61, 4, 22, 82)}
                            })
                        ]),
                        position = {some, markdown_unist_position:new(1, 1, 0, 4, 22, 82)}
                    })
                ]),
                position = {some, markdown_unist_position:new(1, 1, 0, 4, 22, 82)}
            })},
        markdown:to_mdast(
            <<"| none | left | right | center |\n| - | :- | -: | :-: |\n| a |\n| b | c | d | e | f |"/utf8>>,
            markdown_parse_options:gfm()
        ),
        "should support GFM tables as `Table`, `TableRow`, `TableCell`s in mdast"
    ),
    ok.

-spec test_gfm_table_case_66(Config) -> markdown_test:testcase() when
    Config :: ct_suite:ct_config().
test_gfm_table_case_66(_Config) ->
    ?assertEqual(
        {ok,
            markdown_mdast_node:root(#markdown_mdast_root{
                children = ?'vec!'([
                    markdown_mdast_node:table(#markdown_mdast_table{
                        align = ?'vec!'([
                            markdown_align_kind:none()
                        ]),
                        children = ?'vec!'([
                            markdown_mdast_node:table_row(#markdown_mdast_table_row{
                                children = ?'vec!'([
                                    markdown_mdast_node:table_cell(#markdown_mdast_table_cell{
                                        children = ?'vec!'([
                                            markdown_mdast_node:inline_code(#markdown_mdast_inline_code{
                                                value = <<"a|b">>,
                                                position = {some, markdown_unist_position:new(1, 3, 2, 1, 9, 8)}
                                            })
                                        ]),
                                        position = {some, markdown_unist_position:new(1, 1, 0, 1, 11, 10)}
                                    })
                                ]),
                                position = {some, markdown_unist_position:new(1, 1, 0, 1, 11, 10)}
                            })
                        ]),
                        position = {some, markdown_unist_position:new(1, 1, 0, 2, 6, 16)}
                    })
                ]),
                position = {some, markdown_unist_position:new(1, 1, 0, 2, 6, 16)}
            })},
        markdown:to_mdast(<<"| `a\\|b` |\n| - |"/utf8>>, markdown_parse_options:gfm()),
        "should support weird pipe escapes in code in tables"
    ),
    ok.
