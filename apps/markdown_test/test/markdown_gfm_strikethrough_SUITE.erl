%%% % DO NOT EDIT: this file was generated by 'just codegen'
%%% % @generated SignedSource<<cb0695b65eecd0f39fc473b045528a02>>
%%% % @format
%%%-----------------------------------------------------------------------------
%%% Copyright (c) Meta Platforms, Inc. and affiliates.
%%% Copyright (c) WhatsApp LLC
%%%
%%% This source code is licensed under the MIT license found in the
%%% LICENSE.md file in the root directory of this source tree.
%%%-----------------------------------------------------------------------------
-module(markdown_gfm_strikethrough_SUITE).
-moduledoc """

""".
-moduledoc #{author => ["Andrew Bennett <potatosaladx@meta.com>"]}.
-moduledoc #{created => "", modified => ""}.
-moduledoc #{copyright => "Meta Platforms, Inc. and affiliates."}.
-compile(warn_missing_spec_all).
-oncall("whatsapp_clr").

-include_lib("markdown/include/markdown_mdast.hrl").
-include_lib("markdown/include/markdown_util.hrl").
-include_lib("stdlib/include/assert.hrl").

-behaviour(ct_suite).

%% ct_suite callbacks
-export([
    all/0,
    groups/0,
    init_per_suite/1,
    end_per_suite/1,
    init_per_group/2,
    end_per_group/2
]).

%% Test Cases
-export([
    test_gfm_strikethrough_case_1/1,
    test_gfm_strikethrough_case_2/1,
    test_gfm_strikethrough_case_3/1,
    test_gfm_strikethrough_case_4/1,
    test_gfm_strikethrough_case_5/1,
    test_gfm_strikethrough_case_6/1,
    test_gfm_strikethrough_case_7/1,
    test_gfm_strikethrough_case_8/1,
    test_gfm_strikethrough_case_9/1,
    test_gfm_strikethrough_case_10/1,
    test_gfm_strikethrough_case_11/1,
    test_gfm_strikethrough_case_12/1,
    test_gfm_strikethrough_case_13/1,
    test_gfm_strikethrough_case_14/1,
    test_gfm_strikethrough_case_15/1,
    test_gfm_strikethrough_case_16/1,
    test_gfm_strikethrough_case_17/1
]).

%%%=============================================================================
%%% ct_suite callbacks
%%%=============================================================================

-spec all() -> markdown_test:all().
all() ->
    [
        {group, static}
    ].

-spec groups() -> markdown_test:groups().
groups() ->
    [
        {static, [parallel], [
            test_gfm_strikethrough_case_1,
            test_gfm_strikethrough_case_2,
            test_gfm_strikethrough_case_3,
            test_gfm_strikethrough_case_4,
            test_gfm_strikethrough_case_5,
            test_gfm_strikethrough_case_6,
            test_gfm_strikethrough_case_7,
            test_gfm_strikethrough_case_8,
            test_gfm_strikethrough_case_9,
            test_gfm_strikethrough_case_10,
            test_gfm_strikethrough_case_11,
            test_gfm_strikethrough_case_12,
            test_gfm_strikethrough_case_13,
            test_gfm_strikethrough_case_14,
            test_gfm_strikethrough_case_15,
            test_gfm_strikethrough_case_16,
            test_gfm_strikethrough_case_17
        ]}
    ].

-spec init_per_suite(Config :: ct_suite:ct_config()) -> markdown_test:init_per_suite().
init_per_suite(Config) ->
    Config.

-spec end_per_suite(Config :: ct_suite:ct_config()) -> markdown_test:end_per_suite().
end_per_suite(_Config) ->
    ok.

-spec init_per_group(GroupName :: ct_suite:ct_groupname(), Config :: ct_suite:ct_config()) ->
    markdown_test:init_per_group().
init_per_group(_Group, Config) ->
    Config.

-spec end_per_group(GroupName :: ct_suite:ct_groupname(), Config :: ct_suite:ct_config()) ->
    markdown_test:end_per_group().
end_per_group(_Group, _Config) ->
    ok.

%%%=============================================================================
%%% Test Cases
%%%=============================================================================

-spec test_gfm_strikethrough_case_1(Config) -> markdown_test:testcase() when
    Config :: ct_suite:ct_config().
test_gfm_strikethrough_case_1(_Config) ->
    ?assertMatch(
        {ok, <<"<p>a ~b~ c</p>"/utf8>>},
        markdown:to_html(<<"a ~b~ c"/utf8>>),
        "should ignore strikethrough by default"
    ),
    ok.

-spec test_gfm_strikethrough_case_2(Config) -> markdown_test:testcase() when
    Config :: ct_suite:ct_config().
test_gfm_strikethrough_case_2(_Config) ->
    ?assertMatch(
        {ok, <<"<p>a <del>b</del></p>"/utf8>>},
        markdown:to_html_with_options(<<"a ~b~"/utf8>>, markdown_options:gfm()),
        "should support strikethrough w/ one tilde"
    ),
    ok.

-spec test_gfm_strikethrough_case_3(Config) -> markdown_test:testcase() when
    Config :: ct_suite:ct_config().
test_gfm_strikethrough_case_3(_Config) ->
    ?assertMatch(
        {ok, <<"<p>a <del>b</del></p>"/utf8>>},
        markdown:to_html_with_options(<<"a ~~b~~"/utf8>>, markdown_options:gfm()),
        "should support strikethrough w/ two tildes"
    ),
    ok.

-spec test_gfm_strikethrough_case_4(Config) -> markdown_test:testcase() when
    Config :: ct_suite:ct_config().
test_gfm_strikethrough_case_4(_Config) ->
    ?assertMatch(
        {ok, <<"<p>a ~~~b~~~</p>"/utf8>>},
        markdown:to_html_with_options(<<"a ~~~b~~~"/utf8>>, markdown_options:gfm()),
        "should not support strikethrough w/ three tildes"
    ),
    ok.

-spec test_gfm_strikethrough_case_5(Config) -> markdown_test:testcase() when
    Config :: ct_suite:ct_config().
test_gfm_strikethrough_case_5(_Config) ->
    ?assertMatch(
        {ok, <<"<p>a ~<del>b</del> c</p>"/utf8>>},
        markdown:to_html_with_options(<<"a \\~~~b~~ c"/utf8>>, markdown_options:gfm()),
        "should support strikethrough after an escaped tilde"
    ),
    ok.

-spec test_gfm_strikethrough_case_6(Config) -> markdown_test:testcase() when
    Config :: ct_suite:ct_config().
test_gfm_strikethrough_case_6(_Config) ->
    ?assertMatch(
        {ok, <<"<p>a <del>b <del>c</del> d</del> e</p>"/utf8>>},
        markdown:to_html_with_options(<<"a ~~b ~~c~~ d~~ e"/utf8>>, markdown_options:gfm()),
        "should support nested strikethrough"
    ),
    ok.

-spec test_gfm_strikethrough_case_7(Config) -> markdown_test:testcase() when
    Config :: ct_suite:ct_config().
test_gfm_strikethrough_case_7(_Config) ->
    ?assertMatch(
        {ok, <<"<p>a <del>-1</del> b</p>"/utf8>>},
        markdown:to_html_with_options(<<"a ~-1~ b"/utf8>>, markdown_options:gfm()),
        "should open if preceded by whitespace and followed by punctuation"
    ),
    ok.

-spec test_gfm_strikethrough_case_8(Config) -> markdown_test:testcase() when
    Config :: ct_suite:ct_config().
test_gfm_strikethrough_case_8(_Config) ->
    ?assertMatch(
        {ok, <<"<p>a <del>b.</del> c</p>"/utf8>>},
        markdown:to_html_with_options(<<"a ~b.~ c"/utf8>>, markdown_options:gfm()),
        "should close if preceded by punctuation and followed by whitespace"
    ),
    ok.

-spec test_gfm_strikethrough_case_9(Config) -> markdown_test:testcase() when
    Config :: ct_suite:ct_config().
test_gfm_strikethrough_case_9(_Config) ->
    ?assertMatch(
        {ok, <<"<p><del>b.</del>.</p>"/utf8>>},
        markdown:to_html_with_options(<<"~b.~."/utf8>>, markdown_options:gfm()),
        "should close if preceded and followed by punctuation"
    ),
    ok.

-spec test_gfm_strikethrough_case_10(Config) -> markdown_test:testcase() when
    Config :: ct_suite:ct_config().
test_gfm_strikethrough_case_10(_Config) ->
    ?assertMatch(
        {ok,
            <<"<h1>Balanced</h1>\n<p>a <del>one</del> b</p>\n<p>a <del>two</del> b</p>\n<p>a ~~~three~~~ b</p>\n<p>a ~~~~four~~~~ b</p>\n<h1>Unbalanced</h1>\n<p>a ~one/two~~ b</p>\n<p>a ~one/three~~~ b</p>\n<p>a ~one/four~~~~ b</p>\n<hr />\n<p>a ~~two/one~ b</p>\n<p>a ~~two/three~~~ b</p>\n<p>a ~~two/four~~~~ b</p>\n<hr />\n<p>a ~~~three/one~ b</p>\n<p>a ~~~three/two~~ b</p>\n<p>a ~~~three/four~~~~ b</p>\n<hr />\n<p>a ~~~~four/one~ b</p>\n<p>a ~~~~four/two~~ b</p>\n<p>a ~~~~four/three~~~ b</p>\n<h2>Multiple</h2>\n<p>a <del>one b one</del> c one~ d</p>\n<p>a <del>one b two~~ c one</del> d</p>\n<p>a <del>one b one</del> c two~~ d</p>\n<p>a <del>two b two</del> c two~~ d</p>\n<p>a <del>two b one~ c two</del> d</p>\n<p>a <del>two b two</del> c one~ d</p>\n"/utf8>>},
        markdown:to_html_with_options(
            <<"\n# Balanced\n\na ~one~ b\n\na ~~two~~ b\n\na ~~~three~~~ b\n\na ~~~~four~~~~ b\n\n# Unbalanced\n\na ~one/two~~ b\n\na ~one/three~~~ b\n\na ~one/four~~~~ b\n\n***\n\na ~~two/one~ b\n\na ~~two/three~~~ b\n\na ~~two/four~~~~ b\n\n***\n\na ~~~three/one~ b\n\na ~~~three/two~~ b\n\na ~~~three/four~~~~ b\n\n***\n\na ~~~~four/one~ b\n\na ~~~~four/two~~ b\n\na ~~~~four/three~~~ b\n\n## Multiple\n\na ~one b one~ c one~ d\n\na ~one b two~~ c one~ d\n\na ~one b one~ c two~~ d\n\na ~~two b two~~ c two~~ d\n\na ~~two b one~ c two~~ d\n\na ~~two b two~~ c one~ d\n"/utf8>>,
            markdown_options:gfm()
        ),
        "should handle balance like GitHub"
    ),
    ok.

-spec test_gfm_strikethrough_case_11(Config) -> markdown_test:testcase() when
    Config :: ct_suite:ct_config().
test_gfm_strikethrough_case_11(_Config) ->
    ?assertMatch(
        {ok,
            <<"<h1>Flank</h1>\n<p>a oneRight~ b oneRight~ c oneRight~ d</p>\n<p>a oneRight~ b oneRight~ c ~oneLeft d</p>\n<p>a oneRight~ b <del>oneLeft c oneRight</del> d</p>\n<p>a <del>oneLeft b oneRight</del> c oneRight~ d</p>\n<p>a <del>oneLeft b oneRight</del> c ~oneLeft d</p>\n<p>a ~oneLeft b <del>oneLeft c oneRight</del> d</p>\n<p>a ~oneLeft b ~oneLeft c ~oneLeft d</p>\n<hr />\n<p>a twoRight~~ b twoRight~~ c twoRight~~ d</p>\n<p>a twoRight~~ b twoRight~~ c ~~twoLeft d</p>\n<p>a twoRight~~ b <del>twoLeft c twoRight</del> d</p>\n<p>a <del>twoLeft b twoRight</del> c twoRight~~ d</p>\n<p>a <del>twoLeft b twoRight</del> c ~~twoLeft d</p>\n<p>a ~~twoLeft b <del>twoLeft c twoRight</del> d</p>\n<p>a ~~twoLeft b ~~twoLeft c ~~twoLeft d</p>\n"/utf8>>},
        markdown:to_html_with_options(
            <<"\n# Flank\n\na oneRight~ b oneRight~ c oneRight~ d\n\na oneRight~ b oneRight~ c ~oneLeft d\n\na oneRight~ b ~oneLeft c oneRight~ d\n\na ~oneLeft b oneRight~ c oneRight~ d\n\na ~oneLeft b oneRight~ c ~oneLeft d\n\na ~oneLeft b ~oneLeft c oneRight~ d\n\na ~oneLeft b ~oneLeft c ~oneLeft d\n\n***\n\na twoRight~~ b twoRight~~ c twoRight~~ d\n\na twoRight~~ b twoRight~~ c ~~twoLeft d\n\na twoRight~~ b ~~twoLeft c twoRight~~ d\n\na ~~twoLeft b twoRight~~ c twoRight~~ d\n\na ~~twoLeft b twoRight~~ c ~~twoLeft d\n\na ~~twoLeft b ~~twoLeft c twoRight~~ d\n\na ~~twoLeft b ~~twoLeft c ~~twoLeft d\n"/utf8>>,
            markdown_options:gfm()
        ),
        "should handle flanking like GitHub"
    ),
    ok.

-spec test_gfm_strikethrough_case_12(Config) -> markdown_test:testcase() when
    Config :: ct_suite:ct_config().
test_gfm_strikethrough_case_12(_Config) ->
    ?assertMatch(
        {ok,
            <<"<h1>Interlpay</h1>\n<h2>Interleave with attention</h2>\n<p>a <del>two <em>emphasis</em> two</del> b</p>\n<p>a <del>two <strong>strong</strong> two</del> b</p>\n<p>a <em>marker ~~two marker</em> two~~ b</p>\n<p>a <del>two *marker two</del> marker* b</p>\n<h2>Interleave with links</h2>\n<p>a <del>two <a href=\"#\">resource</a> two</del> b</p>\n<p>a <del>two <a href=\"#\">reference</a> two</del> b</p>\n<p>a <a href=\"#\">label start ~~two label end</a> two~~ b</p>\n<p>a ~~two <a href=\"#\">label start two~~ label end</a> b</p>\n<p>a <del>two <a href=\"#\">label start <del>one one</del> label end</a> two</del> b</p>\n<p>a <del>one <a href=\"#\">label start <del>two two</del> label end</a> one</del> b</p>\n<p>a <del>one <a href=\"#\">label start <del>one one</del> label end</a> one</del> b</p>\n<p>a <del>two <a href=\"#\">label start <del>two two</del> label end</a> two</del> b</p>\n<h2>Interleave with code (text)</h2>\n<p>a <del>two <code>code</code> two</del> b</p>\n<p>a ~~two <code>code two~~</code> b</p>\n<p>a <code>code start ~~two code end</code> two~~ b</p>\n<p>a ~~two <code>code start two~~ code end</code> b</p>\n<p>a <del>two <code>code start ~one one~ code end</code> two</del> b</p>\n<p>a <del>one <code>code start ~~two two~~ code end</code> one</del> b</p>\n<p>a <del>one <code>code start ~one one~ code end</code> one</del> b</p>\n<p>a <del>two <code>code start ~~two two~~ code end</code> two</del> b</p>\n<h2>Emphasis/strong/strikethrough interplay</h2>\n<p>a <em><strong><del>xxx</del></strong></em> zzz</p>\n<p>b <em><strong>xxx</strong></em>zzz</p>\n<p>c <strong>xxx</strong>zzz</p>\n<p>d <em>xxx</em>zzz</p>\n<p>e <em><strong><del>xxx</del></strong></em>yyy</p>\n<p>f <strong><del>xxx</del></strong>yyy</p>\n<p>g <em><del>xxx</del></em>yyy</p>\n<p>h <em><strong><del>xxx</del></strong></em> zzz</p>\n<p>i <strong><del>xxx</del></strong> zzz</p>\n<p>j <em><del>xxx</del></em> zzz</p>\n<p>k ~~~<strong>xxx</strong>~~~ zzz</p>\n<p>l ~~~xxx~~~zzz</p>\n<p>m <del>xxx</del>zzz</p>\n<p>n <del>xxx</del>zzz</p>\n<p>o ~~~<strong>xxx</strong>~~~yyy</p>\n<p>p ~~<strong>xxx</strong>~~yyy</p>\n<p>r ~<strong>xxx</strong>~yyy</p>\n<p>s ~~~<strong>xxx</strong>~~~ zzz</p>\n<p>t <del><strong>xxx</strong></del> zzz</p>\n<p>u <del><strong>xxx</strong></del> zzz</p>\n"/utf8>>},
        markdown:to_html_with_options(
            <<"\n# Interlpay\n\n## Interleave with attention\n\na ~~two *emphasis* two~~ b\n\na ~~two **strong** two~~ b\n\na *marker ~~two marker* two~~ b\n\na ~~two *marker two~~ marker* b\n\n## Interleave with links\n\na ~~two [resource](#) two~~ b\n\na ~~two [reference][#] two~~ b\n\na [label start ~~two label end](#) two~~ b\n\na ~~two [label start two~~ label end](#) b\n\na ~~two [label start ~one one~ label end](#) two~~ b\n\na ~one [label start ~~two two~~ label end](#) one~ b\n\na ~one [label start ~one one~ label end](#) one~ b\n\na ~~two [label start ~~two two~~ label end](#) two~~ b\n\n[#]: #\n\n## Interleave with code (text)\n\na ~~two `code` two~~ b\n\na ~~two `code two~~` b\n\na `code start ~~two code end` two~~ b\n\na ~~two `code start two~~ code end` b\n\na ~~two `code start ~one one~ code end` two~~ b\n\na ~one `code start ~~two two~~ code end` one~ b\n\na ~one `code start ~one one~ code end` one~ b\n\na ~~two `code start ~~two two~~ code end` two~~ b\n\n## Emphasis/strong/strikethrough interplay\n\na ***~~xxx~~*** zzz\n\nb ***xxx***zzz\n\nc **xxx**zzz\n\nd *xxx*zzz\n\ne ***~~xxx~~***yyy\n\nf **~~xxx~~**yyy\n\ng *~~xxx~~*yyy\n\nh ***~~xxx~~*** zzz\n\ni **~~xxx~~** zzz\n\nj *~~xxx~~* zzz\n\nk ~~~**xxx**~~~ zzz\n\nl ~~~xxx~~~zzz\n\nm ~~xxx~~zzz\n\nn ~xxx~zzz\n\no ~~~**xxx**~~~yyy\n\np ~~**xxx**~~yyy\n\nr ~**xxx**~yyy\n\ns ~~~**xxx**~~~ zzz\n\nt ~~**xxx**~~ zzz\n\nu ~**xxx**~ zzz\n"/utf8>>,
            markdown_options:gfm()
        ),
        "should handle interplay like GitHub"
    ),
    ok.

-spec test_gfm_strikethrough_case_13(Config) -> markdown_test:testcase() when
    Config :: ct_suite:ct_config().
test_gfm_strikethrough_case_13(_Config) ->
    ?assertMatch(
        {ok, <<"<p>a<em><del>b</del></em>c</p>\n<p>a*.b.*c</p>"/utf8>>},
        markdown:to_html_with_options(<<"a*~b~*c\n\na*.b.*c"/utf8>>, markdown_options:gfm()),
        "should handle interplay w/ other attention markers (GFM)"
    ),
    ok.

-spec test_gfm_strikethrough_case_14(Config) -> markdown_test:testcase() when
    Config :: ct_suite:ct_config().
test_gfm_strikethrough_case_14(_Config) ->
    ?assertMatch(
        {ok, <<"<p>a*~b~*c</p>\n<p>a*.b.*c</p>"/utf8>>},
        markdown:to_html(<<"a*~b~*c\n\na*.b.*c"/utf8>>),
        "should handle interplay w/ other attention markers (CM reference)"
    ),
    ok.

-spec test_gfm_strikethrough_case_15(Config) -> markdown_test:testcase() when
    Config :: ct_suite:ct_config().
test_gfm_strikethrough_case_15(_Config) ->
    ?assertMatch(
        {ok, <<"<p>a ~b~ <del>c</del> d</p>"/utf8>>},
        markdown:to_html_with_options(
            <<"a ~b~ ~~c~~ d"/utf8>>, markdown_options:gfm(#{parse => #{gfm_strikethrough_single_tilde => false}})
        ),
        "should not support strikethrough w/ one tilde if `singleTilde: false`"
    ),
    ok.

-spec test_gfm_strikethrough_case_16(Config) -> markdown_test:testcase() when
    Config :: ct_suite:ct_config().
test_gfm_strikethrough_case_16(_Config) ->
    ?assertMatch(
        {ok, <<"<p>a <del>b</del> <del>c</del> d</p>"/utf8>>},
        markdown:to_html_with_options(
            <<"a ~b~ ~~c~~ d"/utf8>>, markdown_options:gfm(#{parse => #{gfm_strikethrough_single_tilde => true}})
        ),
        "should support strikethrough w/ one tilde if `singleTilde: true`"
    ),
    ok.

-spec test_gfm_strikethrough_case_17(Config) -> markdown_test:testcase() when
    Config :: ct_suite:ct_config().
test_gfm_strikethrough_case_17(_Config) ->
    ?assertEqual(
        {ok,
            markdown_mdast_node:root(#markdown_mdast_root{
                children = ?'vec!'([
                    markdown_mdast_node:paragraph(#markdown_mdast_paragraph{
                        children = ?'vec!'([
                            markdown_mdast_node:text(#markdown_mdast_text{
                                value = <<"a ">>,
                                position = {some, markdown_unist_position:new(1, 1, 0, 1, 3, 2)}
                            }),
                            markdown_mdast_node:delete(#markdown_mdast_delete{
                                children = ?'vec!'([
                                    markdown_mdast_node:text(#markdown_mdast_text{
                                        value = <<"alpha">>,
                                        position = {some, markdown_unist_position:new(1, 5, 4, 1, 10, 9)}
                                    })
                                ]),
                                position = {some, markdown_unist_position:new(1, 3, 2, 1, 12, 11)}
                            }),
                            markdown_mdast_node:text(#markdown_mdast_text{
                                value = <<" b.">>,
                                position = {some, markdown_unist_position:new(1, 12, 11, 1, 15, 14)}
                            })
                        ]),
                        position = {some, markdown_unist_position:new(1, 1, 0, 1, 15, 14)}
                    })
                ]),
                position = {some, markdown_unist_position:new(1, 1, 0, 1, 15, 14)}
            })},
        markdown:to_mdast(<<"a ~~alpha~~ b."/utf8>>, markdown_parse_options:gfm()),
        "should support GFM strikethrough as `Delete`s in mdast"
    ),
    ok.
