%%% % DO NOT EDIT: this file was generated by 'just codegen'
%%% % @generated SignedSource<<bfa837d4c44f6e1643486a42ee49879c>>
%%%-----------------------------------------------------------------------------
%%% %CopyrightBegin%
%%%
%%% SPDX-License-Identifier: Apache-2.0
%%%
%%% Copyright (c) Meta Platforms, Inc. and affiliates.
%%% Copyright (c) WhatsApp LLC
%%%
%%% Licensed under the Apache License, Version 2.0 (the "License");
%%% you may not use this file except in compliance with the License.
%%% You may obtain a copy of the License at
%%%
%%%     http://www.apache.org/licenses/LICENSE-2.0
%%%
%%% Unless required by applicable law or agreed to in writing, software
%%% distributed under the License is distributed on an "AS IS" BASIS,
%%% WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
%%% See the License for the specific language governing permissions and
%%% limitations under the License.
%%%
%%% %CopyrightEnd%
%%%-----------------------------------------------------------------------------
%%% % @format
-module(markdown_resolve).
-moduledoc """
Resolve events.
""".
-moduledoc #{author => ["Andrew Bennett <potatosaladx@meta.com>"]}.
-moduledoc #{created => "2025-03-04", modified => "2025-03-04"}.
-moduledoc #{copyright => "Meta Platforms, Inc. and affiliates."}.
-compile(warn_missing_spec_all).
-oncall("whatsapp_clr").

-include_lib("markdown/include/markdown_parser.hrl").
-include_lib("markdown/include/markdown_resolve.hrl").

%% Call API
-export([
    call/2,
    label/1,
    attention/1,
    gfm_table/1,
    heading_atx/1,
    heading_setext/1,
    list_item/1,
    content/1,
    data/1,
    string/1,
    text/1
]).

%% Types
-doc "Names of resolvers.".
-type name() ::
    label
    | attention
    | gfm_table
    | heading_atx
    | heading_setext
    | list_item
    | content
    | data
    | string
    | text.

-export_type([
    name/0
]).

%%%=============================================================================
%%% Call API functions
%%%=============================================================================

-spec call(Tokenizer, Name) -> {Tokenizer, Result} when
    Tokenizer :: markdown_tokenizer:t(),
    Name :: name(),
    Result :: {ok, OptionSubresult} | {error, Message},
    OptionSubresult :: markdown_types:option(Subresult),
    Subresult :: markdown_subresult:t(),
    Message :: markdown_message:t().
call(Tokenizer1 = #markdown_tokenizer{}, Name) when ?is_markdown_resolve_name(Name) ->
    % TokenizerBeforeString = markdown_debug:rust_debug_string(Tokenizer1),
    % io:format("\n\n[~w:~w] BEFORE resolve:~ts\n\n", [markdown:counter_get(), markdown:stack_push(), markdown_debug:rust_debug_string(Name)]),
    {Tokenizer2, Result} = ?MODULE:Name(Tokenizer1),
    % TokenizerAfterString = markdown_debug:rust_debug_string(Tokenizer2),
    % TokenizerString =
    %     case TokenizerBeforeString =:= TokenizerAfterString of
    %         true ->
    %             <<"NO CHANGE">>;
    %         false ->
    %             TokenizerAfterString
    %     end,
    % io:format("\n\n[~w:~w] AFTER resolve:~ts\n~ts\n~ts\n\n", [markdown:counter_get(), markdown:stack_pop(), markdown_debug:rust_debug_string(Name), markdown_debug:rust_debug_string(Result), TokenizerString]),
    {Tokenizer2, Result}.

-spec label(Tokenizer) -> {Tokenizer, Result} when
    Tokenizer :: markdown_tokenizer:t(),
    Result :: {ok, OptionSubresult} | {error, Message},
    OptionSubresult :: markdown_types:option(Subresult),
    Subresult :: markdown_subresult:t(),
    Message :: markdown_message:t().
-compile({inline, [label/1]}).
label(Tokenizer = #markdown_tokenizer{}) ->
    markdown_construct_label_end:'resolve'(Tokenizer).

-spec attention(Tokenizer) -> {Tokenizer, Result} when
    Tokenizer :: markdown_tokenizer:t(),
    Result :: {ok, OptionSubresult} | {error, Message},
    OptionSubresult :: markdown_types:option(Subresult),
    Subresult :: markdown_subresult:t(),
    Message :: markdown_message:t().
-compile({inline, [attention/1]}).
attention(Tokenizer = #markdown_tokenizer{}) ->
    markdown_construct_attention:'resolve'(Tokenizer).

-spec gfm_table(Tokenizer) -> {Tokenizer, Result} when
    Tokenizer :: markdown_tokenizer:t(),
    Result :: {ok, OptionSubresult} | {error, Message},
    OptionSubresult :: markdown_types:option(Subresult),
    Subresult :: markdown_subresult:t(),
    Message :: markdown_message:t().
-compile({inline, [gfm_table/1]}).
gfm_table(Tokenizer = #markdown_tokenizer{}) ->
    markdown_construct_gfm_table:'resolve'(Tokenizer).

-spec heading_atx(Tokenizer) -> {Tokenizer, Result} when
    Tokenizer :: markdown_tokenizer:t(),
    Result :: {ok, OptionSubresult} | {error, Message},
    OptionSubresult :: markdown_types:option(Subresult),
    Subresult :: markdown_subresult:t(),
    Message :: markdown_message:t().
-compile({inline, [heading_atx/1]}).
heading_atx(Tokenizer = #markdown_tokenizer{}) ->
    markdown_construct_heading_atx:'resolve'(Tokenizer).

-spec heading_setext(Tokenizer) -> {Tokenizer, Result} when
    Tokenizer :: markdown_tokenizer:t(),
    Result :: {ok, OptionSubresult} | {error, Message},
    OptionSubresult :: markdown_types:option(Subresult),
    Subresult :: markdown_subresult:t(),
    Message :: markdown_message:t().
-compile({inline, [heading_setext/1]}).
heading_setext(Tokenizer = #markdown_tokenizer{}) ->
    markdown_construct_heading_setext:'resolve'(Tokenizer).

-spec list_item(Tokenizer) -> {Tokenizer, Result} when
    Tokenizer :: markdown_tokenizer:t(),
    Result :: {ok, OptionSubresult} | {error, Message},
    OptionSubresult :: markdown_types:option(Subresult),
    Subresult :: markdown_subresult:t(),
    Message :: markdown_message:t().
-compile({inline, [list_item/1]}).
list_item(Tokenizer = #markdown_tokenizer{}) ->
    markdown_construct_list_item:'resolve'(Tokenizer).

-spec content(Tokenizer) -> {Tokenizer, Result} when
    Tokenizer :: markdown_tokenizer:t(),
    Result :: {ok, OptionSubresult} | {error, Message},
    OptionSubresult :: markdown_types:option(Subresult),
    Subresult :: markdown_subresult:t(),
    Message :: markdown_message:t().
-compile({inline, [content/1]}).
content(Tokenizer = #markdown_tokenizer{}) ->
    markdown_construct_content:'resolve'(Tokenizer).

-spec data(Tokenizer) -> {Tokenizer, Result} when
    Tokenizer :: markdown_tokenizer:t(),
    Result :: {ok, OptionSubresult} | {error, Message},
    OptionSubresult :: markdown_types:option(Subresult),
    Subresult :: markdown_subresult:t(),
    Message :: markdown_message:t().
-compile({inline, [data/1]}).
data(Tokenizer = #markdown_tokenizer{}) ->
    markdown_construct_partial_data:'resolve'(Tokenizer).

-spec string(Tokenizer) -> {Tokenizer, Result} when
    Tokenizer :: markdown_tokenizer:t(),
    Result :: {ok, OptionSubresult} | {error, Message},
    OptionSubresult :: markdown_types:option(Subresult),
    Subresult :: markdown_subresult:t(),
    Message :: markdown_message:t().
-compile({inline, [string/1]}).
string(Tokenizer = #markdown_tokenizer{}) ->
    markdown_construct_string:'resolve'(Tokenizer).

-spec text(Tokenizer) -> {Tokenizer, Result} when
    Tokenizer :: markdown_tokenizer:t(),
    Result :: {ok, OptionSubresult} | {error, Message},
    OptionSubresult :: markdown_types:option(Subresult),
    Subresult :: markdown_subresult:t(),
    Message :: markdown_message:t().
-compile({inline, [text/1]}).
text(Tokenizer = #markdown_tokenizer{}) ->
    markdown_construct_text:'resolve'(Tokenizer).
