%%%-----------------------------------------------------------------------------
%%% %CopyrightBegin%
%%%
%%% SPDX-License-Identifier: Apache-2.0
%%%
%%% Copyright (c) Meta Platforms, Inc. and affiliates.
%%% Copyright (c) WhatsApp LLC
%%%
%%% Licensed under the Apache License, Version 2.0 (the "License");
%%% you may not use this file except in compliance with the License.
%%% You may obtain a copy of the License at
%%%
%%%     http://www.apache.org/licenses/LICENSE-2.0
%%%
%%% Unless required by applicable law or agreed to in writing, software
%%% distributed under the License is distributed on an "AS IS" BASIS,
%%% WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
%%% See the License for the specific language governing permissions and
%%% limitations under the License.
%%%
%%% %CopyrightEnd%
%%%-----------------------------------------------------------------------------
%%% % @format
-module(markdown_resolve).
-moduledoc """
Resolve events.
""".
-moduledoc #{author => ["Andrew Bennett <potatosaladx@meta.com>"]}.
-moduledoc #{created => "2025-03-04", modified => "2025-03-04"}.
-moduledoc #{copyright => "Meta Platforms, Inc. and affiliates."}.
-compile(warn_missing_spec_all).
-oncall("whatsapp_clr").

-include_lib("markdown/include/markdown_parser.hrl").
-include_lib("markdown/include/markdown_resolve.hrl").

%% Call API
-export([
    call/2,
~J{ set name_api_continue = joiner(",") }.
~J{ for name in ctx.resolve.name_list }.
    ~J< name_api_continue() >.~J< name.key >./1
~J{ endfor }.
]).

%% Types
-doc "Names of resolvers.".
-type name() ::
~J{ set name_type_continue = joiner("| ") }.
~J{ for name in ctx.resolve.name_list }.
    ~J< name_type_continue() >.~J< name.key >.
~J{ endfor }..

-export_type([
    name/0
]).

%%%=============================================================================
%%% Call API functions
%%%=============================================================================

-spec call(Tokenizer, Name) -> {Tokenizer, Result} when
    Tokenizer :: markdown_tokenizer:t(),
    Name :: name(),
    Result :: {ok, OptionSubresult} | {error, Message},
    OptionSubresult :: markdown_types:option(Subresult),
    Subresult :: markdown_subresult:t(),
    Message :: markdown_message:t().
call(Tokenizer1 = #markdown_tokenizer{}, Name) when ?is_markdown_resolve_name(Name) ->
    % TokenizerBeforeString = markdown_debug:rust_debug_string(Tokenizer1),
    % io:format("\n\n[~w:~w] BEFORE resolve:~ts\n\n", [markdown:counter_get(), markdown:stack_push(), markdown_debug:rust_debug_string(Name)]),
    {Tokenizer2, Result} = ?MODULE:Name(Tokenizer1),
    % TokenizerAfterString = markdown_debug:rust_debug_string(Tokenizer2),
    % TokenizerString =
    %     case TokenizerBeforeString =:= TokenizerAfterString of
    %         true ->
    %             <<"NO CHANGE">>;
    %         false ->
    %             TokenizerAfterString
    %     end,
    % io:format("\n\n[~w:~w] AFTER resolve:~ts\n~ts\n~ts\n\n", [markdown:counter_get(), markdown:stack_pop(), markdown_debug:rust_debug_string(Name), markdown_debug:rust_debug_string(Result), TokenizerString]),
    {Tokenizer2, Result}.

~J{ for name in ctx.resolve.name_list }.
-spec ~J< name.key >.(Tokenizer) -> {Tokenizer, Result} when
    Tokenizer :: markdown_tokenizer:t(),
    Result :: {ok, OptionSubresult} | {error, Message},
    OptionSubresult :: markdown_types:option(Subresult),
    Subresult :: markdown_subresult:t(),
    Message :: markdown_message:t().
-compile({inline, [~J< name.key >./1]}).
~J< name.key >.(Tokenizer = #markdown_tokenizer{}) ->
    markdown_construct_~J< name.mod >.:'resolve'(Tokenizer).

~J{ endfor }.
